/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef, EventEmitter, Input, Optional, Output, ViewContainerRef, HostListener, HostBinding, ChangeDetectorRef, } from '@angular/core';
import { isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { throwMdePopoverMissingError } from './popover-errors';
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
var MdePopoverTrigger = /** @class */ (function () {
    function MdePopoverTrigger(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._dir = _dir;
        this._changeDetectorRef = _changeDetectorRef;
        // tslint:disable-line:directive-class-suffix
        this.ariaHaspopup = true;
        this._overlayRef = null;
        this._popoverOpen = false;
        this._halt = false;
        // tracking input type is necessary so it's possible to only auto-focus
        // the first item of the list when the popover is opened via the keyboard
        this._openedByMouse = false;
        /**
         * Popover backdrop close on click
         */
        this.backdropCloseOnClick = true;
        /**
         * Event emitted when the associated popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event emitted when the associated popover is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._checkPopover();
        this._setCurrentConfig();
        this.popover.close.subscribe((/**
         * @return {?}
         */
        function () { return _this.closePopover(); }));
    };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () { this.destroyPopover(); };
    /**
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._setCurrentConfig = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.positionX === 'before' || this.positionX === 'after') {
            this.popover.positionX = this.positionX;
        }
        if (this.positionY === 'above' || this.positionY === 'below') {
            this.popover.positionY = this.positionY;
        }
        if (this.triggerEvent) {
            this.popover.triggerEvent = this.triggerEvent;
        }
        if (this.enterDelay) {
            this.popover.enterDelay = this.enterDelay;
        }
        if (this.leaveDelay) {
            this.popover.leaveDelay = this.leaveDelay;
        }
        if (this.overlapTrigger === true || this.overlapTrigger === false) {
            this.popover.overlapTrigger = this.overlapTrigger;
        }
        if (this.targetOffsetX) {
            this.popover.targetOffsetX = this.targetOffsetX;
        }
        if (this.targetOffsetY) {
            this.popover.targetOffsetY = this.targetOffsetY;
        }
        if (this.arrowOffsetX) {
            this.popover.arrowOffsetX = this.arrowOffsetX;
        }
        if (this.arrowWidth) {
            this.popover.arrowWidth = this.arrowWidth;
        }
        if (this.arrowColor) {
            this.popover.arrowColor = this.arrowColor;
        }
        if (this.closeOnClick === true || this.closeOnClick === false) {
            this.popover.closeOnClick = this.closeOnClick;
        }
        this.popover.setCurrentStyles();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "popoverOpen", {
        /** Whether the popover is open. */
        get: /**
         * Whether the popover is open.
         * @return {?}
         */
        function () { return this._popoverOpen; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.popover.triggerEvent === 'click') {
            // this.popover.setCurrentStyles();
            // this._setCurrentConfig();
            this.togglePopover();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype.onMouseEnter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this._halt = false;
        if (this.popover.triggerEvent === 'hover') {
            this._mouseoverTimer = setTimeout((/**
             * @return {?}
             */
            function () {
                _this.openPopover();
            }), this.popover.enterDelay);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype.onMouseLeave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this.popover.triggerEvent === 'hover') {
            if (this._mouseoverTimer) {
                clearTimeout(this._mouseoverTimer);
                this._mouseoverTimer = null;
            }
            if (this._popoverOpen) {
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    if (!_this.popover.closeDisabled) {
                        _this.closePopover();
                    }
                }), this.popover.leaveDelay);
            }
            else {
                this._halt = true;
            }
        }
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    MdePopoverTrigger.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @return {?}
     */
    MdePopoverTrigger.prototype.openPopover = /**
     * Opens the popover.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen && !this._halt) {
            this._createOverlay().attach(this._portal);
            /** Only subscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._subscribeToBackdrop();
            }
            this._initPopover();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @return {?}
     */
    MdePopoverTrigger.prototype.closePopover = /**
     * Closes the popover.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
            /** Only unsubscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._backdropSubscription.unsubscribe();
            }
            this._resetPopover();
        }
    };
    /** Removes the popover from the DOM. */
    /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    MdePopoverTrigger.prototype.destroyPopover = /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    function () {
        if (this._mouseoverTimer) {
            clearTimeout(this._mouseoverTimer);
            this._mouseoverTimer = null;
        }
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
            this._cleanUpSubscriptions();
        }
    };
    /** Focuses the popover trigger. */
    /**
     * Focuses the popover trigger.
     * @return {?}
     */
    MdePopoverTrigger.prototype.focus = /**
     * Focuses the popover trigger.
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "dir", {
        /** The text direction of the containing app. */
        get: /**
         * The text direction of the containing app.
         * @return {?}
         */
        function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
    * This method ensures that the popover closes when the overlay backdrop is clicked.
    * We do not use first() here because doing so would not catch clicks from within
    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
    * explicitly when the popover is closed or destroyed.
    */
    /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._subscribeToBackdrop = /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._overlayRef) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe((/**
             * @return {?}
             */
            function () {
                _this.popover._emitCloseEvent();
            }));
        }
    };
    /**
    * This method sets the popover state to open and focuses the first item if
    * the popover was opened via the keyboard.
    */
    /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._initPopover = /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    function () {
        this._setIsPopoverOpen(true);
    };
    /**
    * This method resets the popover when it's closed, most importantly restoring
    * focus to the popover trigger if the popover was opened via the keyboard.
    */
    /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._resetPopover = /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    function () {
        this._setIsPopoverOpen(false);
        // Focus only needs to be reset to the host element if the popover was opened
        // by the keyboard and manually shifted to the first popover item.
        if (!this._openedByMouse) {
            this.focus();
        }
        this._openedByMouse = false;
    };
    /** set state rather than toggle to support triggers sharing a popover */
    /**
     * set state rather than toggle to support triggers sharing a popover
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    MdePopoverTrigger.prototype._setIsPopoverOpen = /**
     * set state rather than toggle to support triggers sharing a popover
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    function (isOpen) {
        this._popoverOpen = isOpen;
        this._popoverOpen ? this.opened.emit() : this.closed.emit();
    };
    /**
    *  This method checks that a valid instance of MdPopover has been passed into
    *  mdPopoverTriggerFor. If not, an exception is thrown.
    */
    /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._checkPopover = /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    function () {
        if (!this.popover) {
            throwMdePopoverMissingError();
        }
    };
    /**
    *  This method creates the overlay from the provided popover's template and saves its
    *  OverlayRef so that it can be attached to the DOM when openPopover is called.
    */
    /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._createOverlay = /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @private
     * @return {?}
     */
    function () {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);
            /** @type {?} */
            var config = this._getOverlayConfig();
            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));
            this._overlayRef = this._overlay.create(config);
        }
        return this._overlayRef;
    };
    /**
    * This method builds the configuration object needed to create the overlay, the OverlayConfig.
    * @returns OverlayConfig
    */
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @private
     * @return {?} OverlayConfig
     */
    MdePopoverTrigger.prototype._getOverlayConfig = /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @private
     * @return {?} OverlayConfig
     */
    function () {
        /** @type {?} */
        var overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getPosition();
        /** Display overlay backdrop if trigger event is click */
        if (this.triggerEvent === 'click') {
            overlayState.hasBackdrop = true;
            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
        }
        overlayState.direction = this.dir;
        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        return overlayState;
    };
    /**
    * Listens to changes in the position of the overlay and sets the correct classes
    * on the popover based on the new position. This ensures the animation origin is always
    * correct, even if a fallback position is used for the overlay.
    */
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @private
     * @param {?} position
     * @return {?}
     */
    MdePopoverTrigger.prototype._subscribeToPositions = /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        this._positionSubscription = position.positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            /** @type {?} */
            var posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            /** @type {?} */
            var posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            if (!_this.popover.overlapTrigger) {
                posisionY = posisionY === 'below' ? 'above' : 'below';
            }
            // required for ChangeDetectionStrategy.OnPush
            _this._changeDetectorRef.markForCheck();
            _this.popover.zone.run((/**
             * @return {?}
             */
            function () {
                _this.popover.positionX = posisionX;
                _this.popover.positionY = posisionY;
                _this.popover.setCurrentStyles();
                _this.popover.setPositionClasses(posisionX, posisionY);
            }));
        }));
    };
    /**
    * This method builds the position strategy for the overlay, so the popover is properly connected
    * to the trigger.
    * @returns ConnectedPositionStrategy
    */
    /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @private
     * @return {?} ConnectedPositionStrategy
     */
    MdePopoverTrigger.prototype._getPosition = /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @private
     * @return {?} ConnectedPositionStrategy
     */
    function () {
        var _a = tslib_1.__read(this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
        var _b = tslib_1.__read(this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
        // let originY = overlayY;
        // let fallbackOriginY = overlayFallbackY;
        /** @type {?} */
        var originY = overlayY;
        /** @type {?} */
        var originFallbackY = overlayFallbackY;
        /** @type {?} */
        var overlayX = originX;
        /** @type {?} */
        var overlayFallbackX = originFallbackX;
        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
        if (!this.popover.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        /** @type {?} */
        var offsetX = 0;
        /** @type {?} */
        var offsetY = 0;
        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
            offsetX = Number(this.popover.targetOffsetX);
            // offsetX = -16;
        }
        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
            offsetY = Number(this.popover.targetOffsetY);
            // offsetY = -10;
        }
        /**
         * For overriding position element, when mdePopoverTargetAt has a valid element reference.
         * Useful for sticking popover to parent element and offsetting arrow to trigger element.
         * If undefined defaults to the trigger element reference.
         * @type {?}
         */
        var element = this._elementRef;
        if (typeof this.targetElement !== 'undefined') {
            this.popover.containerPositioning = true;
            element = this.targetElement._elementRef;
        }
        return this._overlay.position()
            .flexibleConnectedTo(element)
            .withPositions([
            {
                originX: originX,
                originY: originY,
                overlayX: overlayX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originFallbackX,
                originY: originY,
                overlayX: overlayFallbackX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originX,
                originY: originFallbackY,
                overlayX: overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
        /*
        return this._overlay.position()
          .connectedTo(element,
              {originX: posX, originY: originY},
              {overlayX: posX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: originY},
              {overlayX: fallbackX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: posX, originY: fallbackOriginY},
              {overlayX: posX, overlayY: fallbackOverlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: fallbackOriginY},
              {overlayX: fallbackX, overlayY: fallbackOverlayY})
          .withOffsetX(offsetX)
          .withOffsetY(offsetY);
          */
    };
    /**
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._cleanUpSubscriptions = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype._handleMousedown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event && !isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
        }
    };
    MdePopoverTrigger.decorators = [
        { type: Directive, args: [{
                    selector: '[mdePopoverTriggerFor]',
                    exportAs: 'mdePopoverTrigger'
                },] }
    ];
    /** @nocollapse */
    MdePopoverTrigger.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: ChangeDetectorRef }
    ]; };
    MdePopoverTrigger.propDecorators = {
        ariaHaspopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
        popover: [{ type: Input, args: ['mdePopoverTriggerFor',] }],
        targetElement: [{ type: Input, args: ['mdePopoverTargetAt',] }],
        positionX: [{ type: Input, args: ['mdePopoverPositionX',] }],
        positionY: [{ type: Input, args: ['mdePopoverPositionY',] }],
        triggerEvent: [{ type: Input, args: ['mdePopoverTriggerOn',] }],
        enterDelay: [{ type: Input, args: ['mdePopoverEnterDelay',] }],
        leaveDelay: [{ type: Input, args: ['mdePopoverLeaveDelay',] }],
        overlapTrigger: [{ type: Input, args: ['mdePopoverOverlapTrigger',] }],
        targetOffsetX: [{ type: Input, args: ['mdePopoverOffsetX',] }],
        targetOffsetY: [{ type: Input, args: ['mdePopoverOffsetY',] }],
        arrowOffsetX: [{ type: Input, args: ['mdePopoverArrowOffsetX',] }],
        arrowWidth: [{ type: Input, args: ['mdePopoverArrowWidth',] }],
        arrowColor: [{ type: Input, args: ['mdePopoverArrowColor',] }],
        closeOnClick: [{ type: Input, args: ['mdePopoverCloseOnClick',] }],
        backdropCloseOnClick: [{ type: Input, args: ['mdePopoverBackdropCloseOnClick',] }],
        opened: [{ type: Output }],
        closed: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onMouseEnter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
        onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
        _handleMousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    return MdePopoverTrigger;
}());
export { MdePopoverTrigger };
if (false) {
    /** @type {?} */
    MdePopoverTrigger.prototype.ariaHaspopup;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._popoverOpen;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._halt;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._backdropSubscription;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._positionSubscription;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._mouseoverTimer;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._openedByMouse;
    /**
     * References the popover instance that the trigger is associated with.
     * @type {?}
     */
    MdePopoverTrigger.prototype.popover;
    /**
     * References the popover target instance that the trigger is associated with.
     * @type {?}
     */
    MdePopoverTrigger.prototype.targetElement;
    /**
     * Position of the popover in the X axis
     * @type {?}
     */
    MdePopoverTrigger.prototype.positionX;
    /**
     * Position of the popover in the Y axis
     * @type {?}
     */
    MdePopoverTrigger.prototype.positionY;
    /**
     * Popover trigger event
     * @type {?}
     */
    MdePopoverTrigger.prototype.triggerEvent;
    /**
     * Popover delay
     * @type {?}
     */
    MdePopoverTrigger.prototype.enterDelay;
    /**
     * Popover delay
     * @type {?}
     */
    MdePopoverTrigger.prototype.leaveDelay;
    /**
     * Popover overlap trigger
     * @type {?}
     */
    MdePopoverTrigger.prototype.overlapTrigger;
    /**
     * Popover target offset x
     * @type {?}
     */
    MdePopoverTrigger.prototype.targetOffsetX;
    /**
     * Popover target offset y
     * @type {?}
     */
    MdePopoverTrigger.prototype.targetOffsetY;
    /**
     * Popover arrow offset x
     * @type {?}
     */
    MdePopoverTrigger.prototype.arrowOffsetX;
    /**
     * Popover arrow width
     * @type {?}
     */
    MdePopoverTrigger.prototype.arrowWidth;
    /**
     * Popover arrow color
     * @type {?}
     */
    MdePopoverTrigger.prototype.arrowColor;
    /**
     * Popover container close on click
     * @type {?}
     */
    MdePopoverTrigger.prototype.closeOnClick;
    /**
     * Popover backdrop close on click
     * @type {?}
     */
    MdePopoverTrigger.prototype.backdropCloseOnClick;
    /**
     * Event emitted when the associated popover is opened.
     * @type {?}
     */
    MdePopoverTrigger.prototype.opened;
    /**
     * Event emitted when the associated popover is closed.
     * @type {?}
     */
    MdePopoverTrigger.prototype.closed;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._overlay;
    /** @type {?} */
    MdePopoverTrigger.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS8iLCJzb3VyY2VzIjpbImxpYi9wb3BvdmVyL3BvcG92ZXItdHJpZ2dlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFFTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBRUwsUUFBUSxFQUNSLE1BQU0sRUFDTixnQkFBZ0IsRUFDaEIsWUFBWSxFQUNaLFdBQVcsRUFDWCxpQkFBaUIsR0FDbEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDcEUsT0FBTyxFQUFhLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzlELE9BQU8sRUFDTCxPQUFPLEVBRVAsYUFBYSxFQUlkLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBTXJELE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7OztBQVMvRDtJQTZFSSwyQkFBb0IsUUFBaUIsRUFBUyxXQUF1QixFQUNuRCxpQkFBbUMsRUFDdkIsSUFBb0IsRUFDaEMsa0JBQXFDO1FBSG5DLGFBQVEsR0FBUixRQUFRLENBQVM7UUFBUyxnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUNuRCxzQkFBaUIsR0FBakIsaUJBQWlCLENBQWtCO1FBQ3ZCLFNBQUksR0FBSixJQUFJLENBQWdCO1FBQ2hDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7O1FBMUVwQixpQkFBWSxHQUFHLElBQUksQ0FBQztRQUcvQyxnQkFBVyxHQUFzQixJQUFJLENBQUM7UUFDdEMsaUJBQVksR0FBRyxLQUFLLENBQUM7UUFDckIsVUFBSyxHQUFHLEtBQUssQ0FBQzs7O1FBUWQsbUJBQWMsR0FBRyxLQUFLLENBQUM7Ozs7UUFpRFUseUJBQW9CLEdB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clxuICBBZnRlclZpZXdJbml0LFxyXG4gIERpcmVjdGl2ZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3B0aW9uYWwsXHJcbiAgT3V0cHV0LFxyXG4gIFZpZXdDb250YWluZXJSZWYsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIEhvc3RCaW5kaW5nLFxyXG4gIENoYW5nZURldGVjdG9yUmVmLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgaXNGYWtlTW91c2Vkb3duRnJvbVNjcmVlblJlYWRlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcclxuaW1wb3J0IHsgRGlyZWN0aW9uLCBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcclxuaW1wb3J0IHtcclxuICBPdmVybGF5LFxyXG4gIE92ZXJsYXlSZWYsXHJcbiAgT3ZlcmxheUNvbmZpZyxcclxuICBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyxcclxuICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXHJcbiAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xyXG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xyXG5cclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwsIE1kZVRhcmdldCB9IGZyb20gJy4vcG9wb3Zlci1pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBvc2l0aW9uWCwgTWRlUG9wb3ZlclBvc2l0aW9uWSwgTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB9IGZyb20gJy4vcG9wb3Zlci10eXBlcyc7XHJcbmltcG9ydCB7IHRocm93TWRlUG9wb3Zlck1pc3NpbmdFcnJvciB9IGZyb20gJy4vcG9wb3Zlci1lcnJvcnMnO1xyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhpcyBkaXJlY3RpdmUgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGFuIG1kZS1wb3BvdmVyIHRhZy4gSXQgaXNcclxuICogcmVzcG9uc2libGUgZm9yIHRvZ2dsaW5nIHRoZSBkaXNwbGF5IG9mIHRoZSBwcm92aWRlZCBwb3BvdmVyIGluc3RhbmNlLlxyXG4gKi9cclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW21kZVBvcG92ZXJUcmlnZ2VyRm9yXScsXHJcbiAgZXhwb3J0QXM6ICdtZGVQb3BvdmVyVHJpZ2dlcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXJUcmlnZ2VyIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpkaXJlY3RpdmUtY2xhc3Mtc3VmZml4XHJcblxyXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtaGFzcG9wdXAnKSBhcmlhSGFzcG9wdXAgPSB0cnVlO1xyXG5cclxuICAgIHByaXZhdGUgX3BvcnRhbDogVGVtcGxhdGVQb3J0YWw8YW55PjtcclxuICAgIHByaXZhdGUgX292ZXJsYXlSZWY6IE92ZXJsYXlSZWYgfCBudWxsID0gbnVsbDtcclxuICAgIHByaXZhdGUgX3BvcG92ZXJPcGVuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9oYWx0ID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9iYWNrZHJvcFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJpdmF0ZSBfcG9zaXRpb25TdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuXHJcbiAgICBwcml2YXRlIF9tb3VzZW92ZXJUaW1lcjogYW55O1xyXG5cclxuICAgIC8vIHRyYWNraW5nIGlucHV0IHR5cGUgaXMgbmVjZXNzYXJ5IHNvIGl0J3MgcG9zc2libGUgdG8gb25seSBhdXRvLWZvY3VzXHJcbiAgICAvLyB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgbGlzdCB3aGVuIHRoZSBwb3BvdmVyIGlzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkXHJcbiAgICBwcml2YXRlIF9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XHJcblxyXG4gICAgLyoqIFJlZmVyZW5jZXMgdGhlIHBvcG92ZXIgaW5zdGFuY2UgdGhhdCB0aGUgdHJpZ2dlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyRm9yJykgcG9wb3ZlcjogTWRlUG9wb3ZlclBhbmVsO1xyXG5cclxuICAgIC8qKiBSZWZlcmVuY2VzIHRoZSBwb3BvdmVyIHRhcmdldCBpbnN0YW5jZSB0aGF0IHRoZSB0cmlnZ2VyIGlzIGFzc29jaWF0ZWQgd2l0aC4gKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclRhcmdldEF0JykgdGFyZ2V0RWxlbWVudDogTWRlVGFyZ2V0O1xyXG5cclxuICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWCBheGlzICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblgnKSBwb3NpdGlvblg6IE1kZVBvcG92ZXJQb3NpdGlvblg7XHJcblxyXG4gICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBZIGF4aXMgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWScpIHBvc2l0aW9uWTogTWRlUG9wb3ZlclBvc2l0aW9uWTtcclxuXHJcbiAgICAvKiogUG9wb3ZlciB0cmlnZ2VyIGV2ZW50ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKSB0cmlnZ2VyRXZlbnQ6IE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQ7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgZGVsYXkgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckVudGVyRGVsYXknKSBlbnRlckRlbGF5OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgZGVsYXkgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckxlYXZlRGVsYXknKSBsZWF2ZURlbGF5OiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgb3ZlcmxhcCB0cmlnZ2VyICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJPdmVybGFwVHJpZ2dlcicpIG92ZXJsYXBUcmlnZ2VyOiBib29sZWFuO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIHRhcmdldCBvZmZzZXQgeCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WCcpIHRhcmdldE9mZnNldFg6IG51bWJlcjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFknKSB0YXJnZXRPZmZzZXRZOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgb2Zmc2V0IHggKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93T2Zmc2V0WCcpIGFycm93T2Zmc2V0WDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKiogUG9wb3ZlciBhcnJvdyB3aWR0aCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dXaWR0aCcpIGFycm93V2lkdGg6IG51bWJlcjtcclxuXHJcblxyXG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgY29sb3IgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93Q29sb3InKSBhcnJvd0NvbG9yOiBzdHJpbmc7XHJcblxyXG5cclxuICAgIC8qKiBQb3BvdmVyIGNvbnRhaW5lciBjbG9zZSBvbiBjbGljayAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQ2xvc2VPbkNsaWNrJykgY2xvc2VPbkNsaWNrOiBib29sZWFuO1xyXG5cclxuXHJcbiAgICAvKiogUG9wb3ZlciBiYWNrZHJvcCBjbG9zZSBvbiBjbGljayAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyQmFja2Ryb3BDbG9zZU9uQ2xpY2snKSBiYWNrZHJvcENsb3NlT25DbGljayA9IHRydWU7XHJcblxyXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBwb3BvdmVyIGlzIG9wZW5lZC4gKi9cclxuICAgIEBPdXRwdXQoKSBvcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG4gICAgLyoqIEV2ZW50IGVtaXR0ZWQgd2hlbiB0aGUgYXNzb2NpYXRlZCBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cclxuICAgIEBPdXRwdXQoKSBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX292ZXJsYXk6IE92ZXJsYXksIHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgICAgICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICAgICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX2RpcjogRGlyZWN0aW9uYWxpdHksXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tQb3BvdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudENvbmZpZygpO1xyXG4gICAgICAgIHRoaXMucG9wb3Zlci5jbG9zZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jbG9zZVBvcG92ZXIoKSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKSB7IHRoaXMuZGVzdHJveVBvcG92ZXIoKTsgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIF9zZXRDdXJyZW50Q29uZmlnKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblggPT09ICdiZWZvcmUnIHx8IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25YID0gdGhpcy5wb3NpdGlvblg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3NpdGlvblkgPT09ICdhYm92ZScgfHwgdGhpcy5wb3NpdGlvblkgPT09ICdiZWxvdycpIHtcclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblkgPSB0aGlzLnBvc2l0aW9uWTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID0gdGhpcy50cmlnZ2VyRXZlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5lbnRlckRlbGF5KSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIuZW50ZXJEZWxheSA9IHRoaXMuZW50ZXJEZWxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmxlYXZlRGVsYXkpIHtcclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5sZWF2ZURlbGF5ID0gdGhpcy5sZWF2ZURlbGF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IHRydWUgfHwgdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLm92ZXJsYXBUcmlnZ2VyID0gdGhpcy5vdmVybGFwVHJpZ2dlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLnRhcmdldE9mZnNldFgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFggPSB0aGlzLnRhcmdldE9mZnNldFg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50YXJnZXRPZmZzZXRZKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZID0gdGhpcy50YXJnZXRPZmZzZXRZO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJyb3dPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd09mZnNldFggPSB0aGlzLmFycm93T2Zmc2V0WDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFycm93V2lkdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmFycm93V2lkdGggPSB0aGlzLmFycm93V2lkdGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hcnJvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd0NvbG9yID0gdGhpcy5hcnJvd0NvbG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrID09PSB0cnVlIHx8IHRoaXMuY2xvc2VPbkNsaWNrID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuY2xvc2VPbkNsaWNrID0gdGhpcy5jbG9zZU9uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBpcyBvcGVuLiAqL1xyXG4gICAgZ2V0IHBvcG92ZXJPcGVuKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fcG9wb3Zlck9wZW47IH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgaWYgKHRoaXMucG9wb3Zlci50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgIC8vIHRoaXMucG9wb3Zlci5zZXRDdXJyZW50U3R5bGVzKCk7XHJcbiAgICAgICAgICAvLyB0aGlzLl9zZXRDdXJyZW50Q29uZmlnKCk7XHJcbiAgICAgICAgICB0aGlzLnRvZ2dsZVBvcG92ZXIoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBbJyRldmVudCddKSBvbk1vdXNlRW50ZXIoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgdGhpcy5faGFsdCA9IGZhbHNlO1xyXG4gICAgICBpZiAodGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgICAgdGhpcy5fbW91c2VvdmVyVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKCk7XHJcbiAgICAgICAgICB9LCB0aGlzLnBvcG92ZXIuZW50ZXJEZWxheSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJywgWyckZXZlbnQnXSkgb25Nb3VzZUxlYXZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnaG92ZXInKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdXNlb3ZlclRpbWVyKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9tb3VzZW92ZXJUaW1lcik7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdXNlb3ZlclRpbWVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3BvcG92ZXJPcGVuKSB7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIuY2xvc2VEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sIHRoaXMucG9wb3Zlci5sZWF2ZURlbGF5KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5faGFsdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIFRvZ2dsZXMgdGhlIHBvcG92ZXIgYmV0d2VlbiB0aGUgb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy4gKi9cclxuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuID8gdGhpcy5jbG9zZVBvcG92ZXIoKSA6IHRoaXMub3BlblBvcG92ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogT3BlbnMgdGhlIHBvcG92ZXIuICovXHJcbiAgICBvcGVuUG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3BvcG92ZXJPcGVuICYmICF0aGlzLl9oYWx0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU92ZXJsYXkoKS5hdHRhY2godGhpcy5fcG9ydGFsKTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBPbmx5IHN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJyAmJiB0aGlzLmJhY2tkcm9wQ2xvc2VPbkNsaWNrID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0aGlzLl9pbml0UG9wb3ZlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogQ2xvc2VzIHRoZSBwb3BvdmVyLiAqL1xyXG4gICAgY2xvc2VQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XHJcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xyXG5cclxuICAgICAgICAgIC8qKiBPbmx5IHVuc3Vic2NyaWJlIHRvIGJhY2tkcm9wIGlmIHRyaWdnZXIgZXZlbnQgaXMgY2xpY2sgKi9cclxuICAgICAgICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2NsaWNrJyAmJiB0aGlzLmJhY2tkcm9wQ2xvc2VPbkNsaWNrID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdGhpcy5fcmVzZXRQb3BvdmVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBSZW1vdmVzIHRoZSBwb3BvdmVyIGZyb20gdGhlIERPTS4gKi9cclxuICAgIGRlc3Ryb3lQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZW92ZXJUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbW91c2VvdmVyVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XHJcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5fY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIEZvY3VzZXMgdGhlIHBvcG92ZXIgdHJpZ2dlci4gKi9cclxuICAgIGZvY3VzKCkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUaGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGNvbnRhaW5pbmcgYXBwLiAqL1xyXG4gICAgZ2V0IGRpcigpOiBEaXJlY3Rpb24ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIGVuc3VyZXMgdGhhdCB0aGUgcG9wb3ZlciBjbG9zZXMgd2hlbiB0aGUgb3ZlcmxheSBiYWNrZHJvcCBpcyBjbGlja2VkLlxyXG4gICAgKiBXZSBkbyBub3QgdXNlIGZpcnN0KCkgaGVyZSBiZWNhdXNlIGRvaW5nIHNvIHdvdWxkIG5vdCBjYXRjaCBjbGlja3MgZnJvbSB3aXRoaW5cclxuICAgICogdGhlIHBvcG92ZXIsIGFuZCBpdCB3b3VsZCBmYWlsIHRvIHVuc3Vic2NyaWJlIHByb3Blcmx5LiBJbnN0ZWFkLCB3ZSB1bnN1YnNjcmliZVxyXG4gICAgKiBleHBsaWNpdGx5IHdoZW4gdGhlIHBvcG92ZXIgaXMgY2xvc2VkIG9yIGRlc3Ryb3llZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb0JhY2tkcm9wKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XHJcbiAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpLnN1YnNjcmliZSgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2Qgc2V0cyB0aGUgcG9wb3ZlciBzdGF0ZSB0byBvcGVuIGFuZCBmb2N1c2VzIHRoZSBmaXJzdCBpdGVtIGlmXHJcbiAgICAqIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZC5cclxuICAgICovXHJcbiAgICBwcml2YXRlIF9pbml0UG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9zZXRJc1BvcG92ZXJPcGVuKHRydWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCByZXNldHMgdGhlIHBvcG92ZXIgd2hlbiBpdCdzIGNsb3NlZCwgbW9zdCBpbXBvcnRhbnRseSByZXN0b3JpbmdcclxuICAgICogZm9jdXMgdG8gdGhlIHBvcG92ZXIgdHJpZ2dlciBpZiB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfcmVzZXRQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3NldElzUG9wb3Zlck9wZW4oZmFsc2UpO1xyXG5cclxuICAgICAgICAvLyBGb2N1cyBvbmx5IG5lZWRzIHRvIGJlIHJlc2V0IHRvIHRoZSBob3N0IGVsZW1lbnQgaWYgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZFxyXG4gICAgICAgIC8vIGJ5IHRoZSBrZXlib2FyZCBhbmQgbWFudWFsbHkgc2hpZnRlZCB0byB0aGUgZmlyc3QgcG9wb3ZlciBpdGVtLlxyXG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkQnlNb3VzZSkge1xyXG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIHNldCBzdGF0ZSByYXRoZXIgdGhhbiB0b2dnbGUgdG8gc3VwcG9ydCB0cmlnZ2VycyBzaGFyaW5nIGEgcG9wb3ZlciAqL1xyXG4gICAgcHJpdmF0ZSBfc2V0SXNQb3BvdmVyT3Blbihpc09wZW46IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb3BvdmVyT3BlbiA9IGlzT3BlbjtcclxuICAgICAgICB0aGlzLl9wb3BvdmVyT3BlbiA/IHRoaXMub3BlbmVkLmVtaXQoKSA6IHRoaXMuY2xvc2VkLmVtaXQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGF0IGEgdmFsaWQgaW5zdGFuY2Ugb2YgTWRQb3BvdmVyIGhhcyBiZWVuIHBhc3NlZCBpbnRvXHJcbiAgICAqICBtZFBvcG92ZXJUcmlnZ2VyRm9yLiBJZiBub3QsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY2hlY2tQb3BvdmVyKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wb3BvdmVyKSB7XHJcbiAgICAgICAgICB0aHJvd01kZVBvcG92ZXJNaXNzaW5nRXJyb3IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqICBUaGlzIG1ldGhvZCBjcmVhdGVzIHRoZSBvdmVybGF5IGZyb20gdGhlIHByb3ZpZGVkIHBvcG92ZXIncyB0ZW1wbGF0ZSBhbmQgc2F2ZXMgaXRzXHJcbiAgICAqICBPdmVybGF5UmVmIHNvIHRoYXQgaXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gd2hlbiBvcGVuUG9wb3ZlciBpcyBjYWxsZWQuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcclxuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcclxuICAgICAgICAgIHRoaXMuX3BvcnRhbCA9IG5ldyBUZW1wbGF0ZVBvcnRhbCh0aGlzLnBvcG92ZXIudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xyXG4gICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5fZ2V0T3ZlcmxheUNvbmZpZygpO1xyXG4gICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9Qb3NpdGlvbnMoY29uZmlnLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KTtcclxuICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYgPSB0aGlzLl9vdmVybGF5LmNyZWF0ZShjb25maWcpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgb3ZlcmxheSwgdGhlIE92ZXJsYXlDb25maWcuXHJcbiAgICAqIEByZXR1cm5zIE92ZXJsYXlDb25maWdcclxuICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRPdmVybGF5Q29uZmlnKCk6IE92ZXJsYXlDb25maWcge1xyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKCk7XHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLl9nZXRQb3NpdGlvbigpO1xyXG5cclxuICAgICAgICAvKiogRGlzcGxheSBvdmVybGF5IGJhY2tkcm9wIGlmIHRyaWdnZXIgZXZlbnQgaXMgY2xpY2sgKi9cclxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycpIHtcclxuICAgICAgICAgIG92ZXJsYXlTdGF0ZS5oYXNCYWNrZHJvcCA9IHRydWU7XHJcbiAgICAgICAgICBvdmVybGF5U3RhdGUuYmFja2Ryb3BDbGFzcyA9ICdjZGstb3ZlcmxheS10cmFuc3BhcmVudC1iYWNrZHJvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBvdmVybGF5U3RhdGUuZGlyZWN0aW9uID0gdGhpcy5kaXI7XHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcclxuICAgICAgICByZXR1cm4gb3ZlcmxheVN0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBMaXN0ZW5zIHRvIGNoYW5nZXMgaW4gdGhlIHBvc2l0aW9uIG9mIHRoZSBvdmVybGF5IGFuZCBzZXRzIHRoZSBjb3JyZWN0IGNsYXNzZXNcclxuICAgICogb24gdGhlIHBvcG92ZXIgYmFzZWQgb24gdGhlIG5ldyBwb3NpdGlvbi4gVGhpcyBlbnN1cmVzIHRoZSBhbmltYXRpb24gb3JpZ2luIGlzIGFsd2F5c1xyXG4gICAgKiBjb3JyZWN0LCBldmVuIGlmIGEgZmFsbGJhY2sgcG9zaXRpb24gaXMgdXNlZCBmb3IgdGhlIG92ZXJsYXkuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9Qb3NpdGlvbnMocG9zaXRpb246IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uID0gcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb3Npc2lvblg6IE1kZVBvcG92ZXJQb3NpdGlvblggPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVggPT09ICdzdGFydCcgPyAnYWZ0ZXInIDogJ2JlZm9yZSc7XHJcbiAgICAgICAgICAgIGxldCBwb3Npc2lvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSBjaGFuZ2UuY29ubmVjdGlvblBhaXIub3ZlcmxheVkgPT09ICd0b3AnID8gJ2JlbG93JyA6ICdhYm92ZSc7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucG9wb3Zlci5vdmVybGFwVHJpZ2dlcikge1xyXG4gICAgICAgICAgICAgICAgcG9zaXNpb25ZID0gcG9zaXNpb25ZID09PSAnYmVsb3cnID8gJ2Fib3ZlJyA6ICdiZWxvdyc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHJlcXVpcmVkIGZvciBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XHJcblxyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuem9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9IHBvc2lzaW9uWDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblkgPSBwb3Npc2lvblk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG5cclxuICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlci5zZXRQb3NpdGlvbkNsYXNzZXMocG9zaXNpb25YLCBwb3Npc2lvblkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgYnVpbGRzIHRoZSBwb3NpdGlvbiBzdHJhdGVneSBmb3IgdGhlIG92ZXJsYXksIHNvIHRoZSBwb3BvdmVyIGlzIHByb3Blcmx5IGNvbm5lY3RlZFxyXG4gICAgKiB0byB0aGUgdHJpZ2dlci5cclxuICAgICogQHJldHVybnMgQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneVxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2dldFBvc2l0aW9uKCk6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSB7XHJcbiAgICAgICAgY29uc3QgW29yaWdpblgsIG9yaWdpbkZhbGxiYWNrWF06IEhvcml6b250YWxDb25uZWN0aW9uUG9zW10gPVxyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgPyBbJ2VuZCcsICdzdGFydCddIDogWydzdGFydCcsICdlbmQnXTtcclxuXHJcbiAgICAgICAgY29uc3QgW292ZXJsYXlZLCBvdmVybGF5RmFsbGJhY2tZXTogVmVydGljYWxDb25uZWN0aW9uUG9zW10gPVxyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWSA9PT0gJ2Fib3ZlJyA/IFsnYm90dG9tJywgJ3RvcCddIDogWyd0b3AnLCAnYm90dG9tJ107XHJcblxyXG4gICAgICAgIC8vIGxldCBvcmlnaW5ZID0gb3ZlcmxheVk7XHJcbiAgICAgICAgLy8gbGV0IGZhbGxiYWNrT3JpZ2luWSA9IG92ZXJsYXlGYWxsYmFja1k7XHJcblxyXG4gICAgICAgIGxldCBvcmlnaW5ZID0gb3ZlcmxheVk7XHJcbiAgICAgICAgbGV0IG9yaWdpbkZhbGxiYWNrWSA9IG92ZXJsYXlGYWxsYmFja1k7XHJcblxyXG4gICAgICAgIGNvbnN0IG92ZXJsYXlYID0gb3JpZ2luWDtcclxuICAgICAgICBjb25zdCBvdmVybGF5RmFsbGJhY2tYID0gb3JpZ2luRmFsbGJhY2tYO1xyXG5cclxuICAgICAgICAvLyBsZXQgW29yaWdpblksIG9yaWdpbkZhbGxiYWNrWV0gPSBbb3ZlcmxheVksIG92ZXJsYXlGYWxsYmFja1ldO1xyXG4gICAgICAgIC8vIGxldCBbb3ZlcmxheVgsIG92ZXJsYXlGYWxsYmFja1hdID0gW29yaWdpblgsIG9yaWdpbkZhbGxiYWNrWF07XHJcblxyXG4gICAgICAgIC8qKiBSZXZlcnNlIG92ZXJsYXlZIGFuZCBmYWxsYmFja092ZXJsYXlZIHdoZW4gb3ZlcmxhcFRyaWdnZXIgaXMgZmFsc2UgKi9cclxuICAgICAgICBpZiAoIXRoaXMucG9wb3Zlci5vdmVybGFwVHJpZ2dlcikge1xyXG4gICAgICAgICAgb3JpZ2luWSA9IG92ZXJsYXlZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XHJcbiAgICAgICAgICBvcmlnaW5GYWxsYmFja1kgPSBvdmVybGF5RmFsbGJhY2tZID09PSAndG9wJyA/ICdib3R0b20nIDogJ3RvcCc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgb2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgbGV0IG9mZnNldFkgPSAwO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFggJiYgIWlzTmFOKE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WCkpKSB7XHJcbiAgICAgICAgICBvZmZzZXRYID0gTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYKTtcclxuICAgICAgICAgIC8vIG9mZnNldFggPSAtMTY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFkgJiYgIWlzTmFOKE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSkpKSB7XHJcbiAgICAgICAgICBvZmZzZXRZID0gTnVtYmVyKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZKTtcclxuICAgICAgICAgIC8vIG9mZnNldFkgPSAtMTA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb3Igb3ZlcnJpZGluZyBwb3NpdGlvbiBlbGVtZW50LCB3aGVuIG1kZVBvcG92ZXJUYXJnZXRBdCBoYXMgYSB2YWxpZCBlbGVtZW50IHJlZmVyZW5jZS5cclxuICAgICAgICAgKiBVc2VmdWwgZm9yIHN0aWNraW5nIHBvcG92ZXIgdG8gcGFyZW50IGVsZW1lbnQgYW5kIG9mZnNldHRpbmcgYXJyb3cgdG8gdHJpZ2dlciBlbGVtZW50LlxyXG4gICAgICAgICAqIElmIHVuZGVmaW5lZCBkZWZhdWx0cyB0byB0aGUgdHJpZ2dlciBlbGVtZW50IHJlZmVyZW5jZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBsZXQgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRhcmdldEVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5jb250YWluZXJQb3NpdGlvbmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLnRhcmdldEVsZW1lbnQuX2VsZW1lbnRSZWY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXHJcbiAgICAgICAgLmZsZXhpYmxlQ29ubmVjdGVkVG8oZWxlbWVudClcclxuICAgICAgICAud2l0aFBvc2l0aW9ucyhbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgb3JpZ2luWCxcclxuICAgICAgICAgICAgICBvcmlnaW5ZLFxyXG4gICAgICAgICAgICAgIG92ZXJsYXlYLFxyXG4gICAgICAgICAgICAgIG92ZXJsYXlZLFxyXG4gICAgICAgICAgICAgIG9mZnNldFlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgb3JpZ2luWDogb3JpZ2luRmFsbGJhY2tYLFxyXG4gICAgICAgICAgICAgIG9yaWdpblksXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVg6IG92ZXJsYXlGYWxsYmFja1gsXHJcbiAgICAgICAgICAgICAgb3ZlcmxheVksXHJcbiAgICAgICAgICAgICAgb2Zmc2V0WVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgb3JpZ2luWCxcclxuICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvdmVybGF5WCxcclxuICAgICAgICAgICAgb3ZlcmxheVk6IG92ZXJsYXlGYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG9mZnNldFk6IC1vZmZzZXRZXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXHJcbiAgICAgICAgICAgIG9yaWdpblk6IG9yaWdpbkZhbGxiYWNrWSxcclxuICAgICAgICAgICAgb3ZlcmxheVg6IG92ZXJsYXlGYWxsYmFja1gsXHJcbiAgICAgICAgICAgIG92ZXJsYXlZOiBvdmVybGF5RmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvZmZzZXRZOiAtb2Zmc2V0WVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0pXHJcbiAgICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WChvZmZzZXRYKVxyXG4gICAgICAgIC53aXRoRGVmYXVsdE9mZnNldFkob2Zmc2V0WSk7XHJcbiAgICAgICAgLypcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheS5wb3NpdGlvbigpXHJcbiAgICAgICAgICAuY29ubmVjdGVkVG8oZWxlbWVudCxcclxuICAgICAgICAgICAgICB7b3JpZ2luWDogcG9zWCwgb3JpZ2luWTogb3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBwb3NYLCBvdmVybGF5WTogb3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBmYWxsYmFja1gsIG9yaWdpblk6IG9yaWdpbll9LFxyXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogZmFsbGJhY2tYLCBvdmVybGF5WTogb3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBwb3NYLCBvcmlnaW5ZOiBmYWxsYmFja09yaWdpbll9LFxyXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IGZhbGxiYWNrT3ZlcmxheVl9KVxyXG4gICAgICAgICAgLndpdGhGYWxsYmFja1Bvc2l0aW9uKFxyXG4gICAgICAgICAgICAgIHtvcmlnaW5YOiBmYWxsYmFja1gsIG9yaWdpblk6IGZhbGxiYWNrT3JpZ2luWX0sXHJcbiAgICAgICAgICAgICAge292ZXJsYXlYOiBmYWxsYmFja1gsIG92ZXJsYXlZOiBmYWxsYmFja092ZXJsYXlZfSlcclxuICAgICAgICAgIC53aXRoT2Zmc2V0WChvZmZzZXRYKVxyXG4gICAgICAgICAgLndpdGhPZmZzZXRZKG9mZnNldFkpO1xyXG4gICAgICAgICAgKi9cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9jbGVhblVwU3Vic2NyaXB0aW9ucygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50J10pIF9oYW5kbGVNb3VzZWRvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAoZXZlbnQgJiYgIWlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIoZXZlbnQpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZEJ5TW91c2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iXX0=