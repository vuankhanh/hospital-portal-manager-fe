import { Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, NgZone, HostBinding, Input, Output, ViewChild, TemplateRef, EventEmitter, Directive, ViewContainerRef, Optional, ChangeDetectorRef, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { OverlayConfig, Overlay, OverlayModule } from '@angular/cdk/overlay';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { trigger, state, style, transition, animate } from '@angular/animations';
import { __read } from 'tslib';
import { isFakeMousedownFromScreenReader, A11yModule } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { TemplatePortal } from '@angular/cdk/portal';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Throws an exception for the case when popover trigger doesn't have a valid mde-popover instance
 * @return {?}
 */
function throwMdePopoverMissingError() {
    throw Error("mde-popover-trigger: must pass in an mde-popover instance.\n\n    Example:\n      <mde-popover #popover=\"mdePopover\"></mde-popover>\n      <button [mdePopoverTriggerFor]=\"popover\"></button>");
}
/**
 * Throws an exception for the case when popover's mdePopoverPositionX value isn't valid.
 * In other words, it doesn't match 'before' or 'after'.
 * @return {?}
 */
function throwMdePopoverInvalidPositionX() {
    throw Error("mdePopoverPositionX value must be either 'before' or after'.\n      Example: <mde-popover mdePopoverPositionX=\"before\" #popover=\"mdePopover\"></mde-popover>");
}
/**
 * Throws an exception for the case when popover's mdePopoverPositionY value isn't valid.
 * In other words, it doesn't match 'above' or 'below'.
 * @return {?}
 */
function throwMdePopoverInvalidPositionY() {
    throw Error("mdePopoverPositionY value must be either 'above' or below'.\n      Example: <mde-popover mdePopoverPositionY=\"above\" #popover=\"mdePopover\"></mde-popover>");
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This animation controls the popover panel's entry and exit from the page.
 *
 * When the popover panel is added to the DOM, it scales in and fades in its border.
 *
 * When the popover panel is removed from the DOM, it simply fades out after a brief
 * delay to display the ripple.
 * @type {?}
 */
var transformPopover = trigger('transformPopover', [
    state('enter', style({
        opacity: 1,
        transform: "scale(1)"
    })),
    transition('void => *', [
        style({
            opacity: 0,
            transform: "scale(0)"
        }),
        animate("200ms cubic-bezier(0.25, 0.8, 0.25, 1)")
    ]),
    transition('* => void', [
        animate('50ms 100ms linear', style({ opacity: 0 }))
    ])
]);

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MdePopover = /** @class */ (function () {
    function MdePopover(_elementRef, zone) {
        this._elementRef = _elementRef;
        this.zone = zone;
        // tslint:disable-line:component-class-suffix
        this.role = 'dialog';
        /**
         * Settings for popover, view setters and getters for more detail
         */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._disableAnimation = false;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        this._focusTrapAutoCaptureEnabled = true;
        /**
         * Config object to be passed into the popover's ngClass
         */
        this._classList = {};
        // TODO: Write comment description
        /**
         *
         */
        this.containerPositioning = false;
        /**
         * Closing disabled on popover
         */
        this.closeDisabled = false;
        /**
         * Emits the current animation state whenever it changes.
         */
        this._onAnimationStateChange = new EventEmitter();
        /**
         * Event emitted when the popover is closed.
         */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    Object.defineProperty(MdePopover.prototype, "positionX", {
        /** Position of the popover in the X axis. */
        get: /**
         * Position of the popover in the X axis.
         * @return {?}
         */
        function () { return this._positionX; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'before' && value !== 'after') {
                throwMdePopoverInvalidPositionX();
            }
            this._positionX = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "positionY", {
        /** Position of the popover in the Y axis. */
        get: /**
         * Position of the popover in the Y axis.
         * @return {?}
         */
        function () { return this._positionY; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== 'above' && value !== 'below') {
                throwMdePopoverInvalidPositionY();
            }
            this._positionY = value;
            this.setPositionClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "triggerEvent", {
        /** Popover trigger event */
        get: /**
         * Popover trigger event
         * @return {?}
         */
        function () { return this._triggerEvent; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._triggerEvent = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "enterDelay", {
        /** Popover enter delay */
        get: /**
         * Popover enter delay
         * @return {?}
         */
        function () { return this._enterDelay; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._enterDelay = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "leaveDelay", {
        /** Popover leave delay */
        get: /**
         * Popover leave delay
         * @return {?}
         */
        function () { return this._leaveDelay; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._leaveDelay = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "overlapTrigger", {
        /** Popover overlap trigger */
        get: /**
         * Popover overlap trigger
         * @return {?}
         */
        function () { return this._overlapTrigger; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._overlapTrigger = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetX", {
        /** Popover target offset x */
        get: /**
         * Popover target offset x
         * @return {?}
         */
        function () { return this._targetOffsetX; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._targetOffsetX = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "targetOffsetY", {
        /** Popover target offset y */
        get: /**
         * Popover target offset y
         * @return {?}
         */
        function () { return this._targetOffsetY; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._targetOffsetY = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowOffsetX", {
        /** Popover arrow offset x */
        get: /**
         * Popover arrow offset x
         * @return {?}
         */
        function () { return this._arrowOffsetX; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._arrowOffsetX = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowWidth", {
        /** Popover arrow width */
        get: /**
         * Popover arrow width
         * @return {?}
         */
        function () { return this._arrowWidth; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._arrowWidth = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "arrowColor", {
        /** Popover arrow color */
        get: /**
         * Popover arrow color
         * @return {?}
         */
        function () { return this._arrowColor; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._arrowColor = value; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "closeOnClick", {
        /**
         * Popover container close on click
         * default: true
         */
        get: /**
         * Popover container close on click
         * default: true
         * @return {?}
         */
        function () { return this._closeOnClick; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._closeOnClick = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "disableAnimation", {
        /**
         * Disable animations of popover and all child elements
         * default: false
         */
        get: /**
         * Disable animations of popover and all child elements
         * default: false
         * @return {?}
         */
        function () { return this._disableAnimation; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._disableAnimation = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "focusTrapEnabled", {
        /**
         * Popover focus trap using cdkTrapFocus
         * default: true
         */
        get: /**
         * Popover focus trap using cdkTrapFocus
         * default: true
         * @return {?}
         */
        function () { return this._focusTrapEnabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._focusTrapEnabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "focusTrapAutoCaptureEnabled", {
        /**
         * Popover focus trap auto capture using cdkTrapFocusAutoCapture
         * default: true
         */
        get: /**
         * Popover focus trap auto capture using cdkTrapFocusAutoCapture
         * default: true
         * @return {?}
         */
        function () { return this._focusTrapAutoCaptureEnabled; },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "panelClass", {
        /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @param classes list of class names
         */
        set: /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @param {?} classes list of class names
         * @return {?}
         */
        function (classes) {
            if (classes && classes.length) {
                this._classList = classes.split(' ').reduce((/**
                 * @param {?} obj
                 * @param {?} className
                 * @return {?}
                 */
                function (obj, className) {
                    obj[className] = true;
                    return obj;
                }), {});
                this._elementRef.nativeElement.className = '';
                this.setPositionClasses();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MdePopover.prototype, "classList", {
        /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @deprecated Use `panelClass` instead.
         */
        get: /**
         * This method takes classes set on the host md-popover element and applies them on the
         * popover template that displays in the overlay container.  Otherwise, it's difficult
         * to style the containing popover from outside the component.
         * @deprecated Use `panelClass` instead.
         * @return {?}
         */
        function () { return this.panelClass; },
        set: /**
         * @param {?} classes
         * @return {?}
         */
        function (classes) { this.panelClass = classes; },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MdePopover.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._emitCloseEvent();
        this.close.complete();
    };
    /** Handle a keyboard event from the popover, delegating to the appropriate action. */
    /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    MdePopover.prototype._handleKeydown = /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    };
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     */
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    MdePopover.prototype._emitCloseEvent = /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    function () {
        this.close.emit();
    };
    /** Close popover on click if closeOnClick is true */
    /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    MdePopover.prototype.onClick = /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    function () {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    };
    /**
     * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
     * https://github.com/angular/material2/pull/5493#issuecomment-313085323
     */
    /** Disables close of popover when leaving trigger element and mouse over the popover */
    /**
       * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
       * https://github.com/angular/material2/pull/5493#issuecomment-313085323
       */
    /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    MdePopover.prototype.onMouseOver = /**
       * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
       * https://github.com/angular/material2/pull/5493#issuecomment-313085323
       */
    /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    };
    /** Enables close of popover when mouse leaving popover element */
    /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    MdePopover.prototype.onMouseLeave = /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    function () {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    };
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /** Sets the current styles for the popover to allow for dynamically changing settings */
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    MdePopover.prototype.setCurrentStyles = 
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    function () {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    };
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     */
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    MdePopover.prototype.setPositionClasses = /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    function (posX, posY) {
        if (posX === void 0) { posX = this.positionX; }
        if (posY === void 0) { posY = this.positionY; }
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    };
    MdePopover.decorators = [
        { type: Component, args: [{
                    selector: 'mde-popover',
                    template: "<ng-template>\r\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\r\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\r\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\" [@.disabled]=\"disableAnimation\"\r\n       [@transformPopover]=\"'enter'\">\r\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\r\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" [cdkTrapFocus]=\"focusTrapEnabled\" [cdkTrapFocusAutoCapture]=\"focusTrapAutoCaptureEnabled\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  </div>\r\n</ng-template>\r\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    encapsulation: ViewEncapsulation.None,
                    animations: [
                        transformPopover
                    ],
                    exportAs: 'mdePopover',
                    styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"]
                }] }
    ];
    /** @nocollapse */
    MdePopover.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    MdePopover.propDecorators = {
        role: [{ type: HostBinding, args: ['attr.role',] }],
        positionX: [{ type: Input, args: ['mdePopoverPositionX',] }],
        positionY: [{ type: Input, args: ['mdePopoverPositionY',] }],
        triggerEvent: [{ type: Input, args: ['mdePopoverTriggerOn',] }],
        enterDelay: [{ type: Input, args: ['mdePopoverEnterDelay',] }],
        leaveDelay: [{ type: Input, args: ['mdePopoverLeaveDelay',] }],
        overlapTrigger: [{ type: Input, args: ['mdePopoverOverlapTrigger',] }],
        targetOffsetX: [{ type: Input, args: ['mdePopoverOffsetX',] }],
        targetOffsetY: [{ type: Input, args: ['mdePopoverOffsetY',] }],
        arrowOffsetX: [{ type: Input, args: ['mdePopoverArrowOffsetX',] }],
        arrowWidth: [{ type: Input, args: ['mdePopoverArrowWidth',] }],
        arrowColor: [{ type: Input, args: ['mdePopoverArrowColor',] }],
        closeOnClick: [{ type: Input, args: ['mdePopoverCloseOnClick',] }],
        disableAnimation: [{ type: Input, args: ['mdePopoverDisableAnimation',] }],
        focusTrapEnabled: [{ type: Input, args: ['mdeFocusTrapEnabled',] }],
        focusTrapAutoCaptureEnabled: [{ type: Input, args: ['mdeFocusTrapAutoCaptureEnabled',] }],
        panelClass: [{ type: Input, args: ['class',] }],
        classList: [{ type: Input }],
        close: [{ type: Output }],
        templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }]
    };
    return MdePopover;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
var MdePopoverTrigger = /** @class */ (function () {
    function MdePopoverTrigger(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._dir = _dir;
        this._changeDetectorRef = _changeDetectorRef;
        // tslint:disable-line:directive-class-suffix
        this.ariaHaspopup = true;
        this._overlayRef = null;
        this._popoverOpen = false;
        this._halt = false;
        // tracking input type is necessary so it's possible to only auto-focus
        // the first item of the list when the popover is opened via the keyboard
        this._openedByMouse = false;
        /**
         * Popover backdrop close on click
         */
        this.backdropCloseOnClick = true;
        /**
         * Event emitted when the associated popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event emitted when the associated popover is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._checkPopover();
        this._setCurrentConfig();
        this.popover.close.subscribe((/**
         * @return {?}
         */
        function () { return _this.closePopover(); }));
    };
    /**
     * @return {?}
     */
    MdePopoverTrigger.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () { this.destroyPopover(); };
    /**
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._setCurrentConfig = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.positionX === 'before' || this.positionX === 'after') {
            this.popover.positionX = this.positionX;
        }
        if (this.positionY === 'above' || this.positionY === 'below') {
            this.popover.positionY = this.positionY;
        }
        if (this.triggerEvent) {
            this.popover.triggerEvent = this.triggerEvent;
        }
        if (this.enterDelay) {
            this.popover.enterDelay = this.enterDelay;
        }
        if (this.leaveDelay) {
            this.popover.leaveDelay = this.leaveDelay;
        }
        if (this.overlapTrigger === true || this.overlapTrigger === false) {
            this.popover.overlapTrigger = this.overlapTrigger;
        }
        if (this.targetOffsetX) {
            this.popover.targetOffsetX = this.targetOffsetX;
        }
        if (this.targetOffsetY) {
            this.popover.targetOffsetY = this.targetOffsetY;
        }
        if (this.arrowOffsetX) {
            this.popover.arrowOffsetX = this.arrowOffsetX;
        }
        if (this.arrowWidth) {
            this.popover.arrowWidth = this.arrowWidth;
        }
        if (this.arrowColor) {
            this.popover.arrowColor = this.arrowColor;
        }
        if (this.closeOnClick === true || this.closeOnClick === false) {
            this.popover.closeOnClick = this.closeOnClick;
        }
        this.popover.setCurrentStyles();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "popoverOpen", {
        /** Whether the popover is open. */
        get: /**
         * Whether the popover is open.
         * @return {?}
         */
        function () { return this._popoverOpen; },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.popover.triggerEvent === 'click') {
            // this.popover.setCurrentStyles();
            // this._setCurrentConfig();
            this.togglePopover();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype.onMouseEnter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this._halt = false;
        if (this.popover.triggerEvent === 'hover') {
            this._mouseoverTimer = setTimeout((/**
             * @return {?}
             */
            function () {
                _this.openPopover();
            }), this.popover.enterDelay);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype.onMouseLeave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this.popover.triggerEvent === 'hover') {
            if (this._mouseoverTimer) {
                clearTimeout(this._mouseoverTimer);
                this._mouseoverTimer = null;
            }
            if (this._popoverOpen) {
                setTimeout((/**
                 * @return {?}
                 */
                function () {
                    if (!_this.popover.closeDisabled) {
                        _this.closePopover();
                    }
                }), this.popover.leaveDelay);
            }
            else {
                this._halt = true;
            }
        }
    };
    /** Toggles the popover between the open and closed states. */
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    MdePopoverTrigger.prototype.togglePopover = /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    function () {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    };
    /** Opens the popover. */
    /**
     * Opens the popover.
     * @return {?}
     */
    MdePopoverTrigger.prototype.openPopover = /**
     * Opens the popover.
     * @return {?}
     */
    function () {
        if (!this._popoverOpen && !this._halt) {
            this._createOverlay().attach(this._portal);
            /** Only subscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._subscribeToBackdrop();
            }
            this._initPopover();
        }
    };
    /** Closes the popover. */
    /**
     * Closes the popover.
     * @return {?}
     */
    MdePopoverTrigger.prototype.closePopover = /**
     * Closes the popover.
     * @return {?}
     */
    function () {
        if (this._overlayRef) {
            this._overlayRef.detach();
            /** Only unsubscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._backdropSubscription.unsubscribe();
            }
            this._resetPopover();
        }
    };
    /** Removes the popover from the DOM. */
    /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    MdePopoverTrigger.prototype.destroyPopover = /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    function () {
        if (this._mouseoverTimer) {
            clearTimeout(this._mouseoverTimer);
            this._mouseoverTimer = null;
        }
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
            this._cleanUpSubscriptions();
        }
    };
    /** Focuses the popover trigger. */
    /**
     * Focuses the popover trigger.
     * @return {?}
     */
    MdePopoverTrigger.prototype.focus = /**
     * Focuses the popover trigger.
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    Object.defineProperty(MdePopoverTrigger.prototype, "dir", {
        /** The text direction of the containing app. */
        get: /**
         * The text direction of the containing app.
         * @return {?}
         */
        function () {
            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
        },
        enumerable: true,
        configurable: true
    });
    /**
    * This method ensures that the popover closes when the overlay backdrop is clicked.
    * We do not use first() here because doing so would not catch clicks from within
    * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
    * explicitly when the popover is closed or destroyed.
    */
    /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._subscribeToBackdrop = /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._overlayRef) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe((/**
             * @return {?}
             */
            function () {
                _this.popover._emitCloseEvent();
            }));
        }
    };
    /**
    * This method sets the popover state to open and focuses the first item if
    * the popover was opened via the keyboard.
    */
    /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._initPopover = /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    function () {
        this._setIsPopoverOpen(true);
    };
    /**
    * This method resets the popover when it's closed, most importantly restoring
    * focus to the popover trigger if the popover was opened via the keyboard.
    */
    /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._resetPopover = /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    function () {
        this._setIsPopoverOpen(false);
        // Focus only needs to be reset to the host element if the popover was opened
        // by the keyboard and manually shifted to the first popover item.
        if (!this._openedByMouse) {
            this.focus();
        }
        this._openedByMouse = false;
    };
    /** set state rather than toggle to support triggers sharing a popover */
    /**
     * set state rather than toggle to support triggers sharing a popover
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    MdePopoverTrigger.prototype._setIsPopoverOpen = /**
     * set state rather than toggle to support triggers sharing a popover
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    function (isOpen) {
        this._popoverOpen = isOpen;
        this._popoverOpen ? this.opened.emit() : this.closed.emit();
    };
    /**
    *  This method checks that a valid instance of MdPopover has been passed into
    *  mdPopoverTriggerFor. If not, an exception is thrown.
    */
    /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._checkPopover = /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    function () {
        if (!this.popover) {
            throwMdePopoverMissingError();
        }
    };
    /**
    *  This method creates the overlay from the provided popover's template and saves its
    *  OverlayRef so that it can be attached to the DOM when openPopover is called.
    */
    /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._createOverlay = /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @private
     * @return {?}
     */
    function () {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);
            /** @type {?} */
            var config = this._getOverlayConfig();
            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));
            this._overlayRef = this._overlay.create(config);
        }
        return this._overlayRef;
    };
    /**
    * This method builds the configuration object needed to create the overlay, the OverlayConfig.
    * @returns OverlayConfig
    */
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @private
     * @return {?} OverlayConfig
     */
    MdePopoverTrigger.prototype._getOverlayConfig = /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @private
     * @return {?} OverlayConfig
     */
    function () {
        /** @type {?} */
        var overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getPosition();
        /** Display overlay backdrop if trigger event is click */
        if (this.triggerEvent === 'click') {
            overlayState.hasBackdrop = true;
            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
        }
        overlayState.direction = this.dir;
        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        return overlayState;
    };
    /**
    * Listens to changes in the position of the overlay and sets the correct classes
    * on the popover based on the new position. This ensures the animation origin is always
    * correct, even if a fallback position is used for the overlay.
    */
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @private
     * @param {?} position
     * @return {?}
     */
    MdePopoverTrigger.prototype._subscribeToPositions = /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        var _this = this;
        this._positionSubscription = position.positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        function (change) {
            /** @type {?} */
            var posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            /** @type {?} */
            var posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            if (!_this.popover.overlapTrigger) {
                posisionY = posisionY === 'below' ? 'above' : 'below';
            }
            // required for ChangeDetectionStrategy.OnPush
            _this._changeDetectorRef.markForCheck();
            _this.popover.zone.run((/**
             * @return {?}
             */
            function () {
                _this.popover.positionX = posisionX;
                _this.popover.positionY = posisionY;
                _this.popover.setCurrentStyles();
                _this.popover.setPositionClasses(posisionX, posisionY);
            }));
        }));
    };
    /**
    * This method builds the position strategy for the overlay, so the popover is properly connected
    * to the trigger.
    * @returns ConnectedPositionStrategy
    */
    /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @private
     * @return {?} ConnectedPositionStrategy
     */
    MdePopoverTrigger.prototype._getPosition = /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @private
     * @return {?} ConnectedPositionStrategy
     */
    function () {
        var _a = __read(this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'], 2), originX = _a[0], originFallbackX = _a[1];
        var _b = __read(this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'], 2), overlayY = _b[0], overlayFallbackY = _b[1];
        // let originY = overlayY;
        // let fallbackOriginY = overlayFallbackY;
        /** @type {?} */
        var originY = overlayY;
        /** @type {?} */
        var originFallbackY = overlayFallbackY;
        /** @type {?} */
        var overlayX = originX;
        /** @type {?} */
        var overlayFallbackX = originFallbackX;
        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
        if (!this.popover.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        /** @type {?} */
        var offsetX = 0;
        /** @type {?} */
        var offsetY = 0;
        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
            offsetX = Number(this.popover.targetOffsetX);
            // offsetX = -16;
        }
        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
            offsetY = Number(this.popover.targetOffsetY);
            // offsetY = -10;
        }
        /**
         * For overriding position element, when mdePopoverTargetAt has a valid element reference.
         * Useful for sticking popover to parent element and offsetting arrow to trigger element.
         * If undefined defaults to the trigger element reference.
         * @type {?}
         */
        var element = this._elementRef;
        if (typeof this.targetElement !== 'undefined') {
            this.popover.containerPositioning = true;
            element = this.targetElement._elementRef;
        }
        return this._overlay.position()
            .flexibleConnectedTo(element)
            .withPositions([
            {
                originX: originX,
                originY: originY,
                overlayX: overlayX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originFallbackX,
                originY: originY,
                overlayX: overlayFallbackX,
                overlayY: overlayY,
                offsetY: offsetY
            },
            {
                originX: originX,
                originY: originFallbackY,
                overlayX: overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
        /*
        return this._overlay.position()
          .connectedTo(element,
              {originX: posX, originY: originY},
              {overlayX: posX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: originY},
              {overlayX: fallbackX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: posX, originY: fallbackOriginY},
              {overlayX: posX, overlayY: fallbackOverlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: fallbackOriginY},
              {overlayX: fallbackX, overlayY: fallbackOverlayY})
          .withOffsetX(offsetX)
          .withOffsetY(offsetY);
          */
    };
    /**
     * @private
     * @return {?}
     */
    MdePopoverTrigger.prototype._cleanUpSubscriptions = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MdePopoverTrigger.prototype._handleMousedown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event && !isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
        }
    };
    MdePopoverTrigger.decorators = [
        { type: Directive, args: [{
                    selector: '[mdePopoverTriggerFor]',
                    exportAs: 'mdePopoverTrigger'
                },] }
    ];
    /** @nocollapse */
    MdePopoverTrigger.ctorParameters = function () { return [
        { type: Overlay },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: Directionality, decorators: [{ type: Optional }] },
        { type: ChangeDetectorRef }
    ]; };
    MdePopoverTrigger.propDecorators = {
        ariaHaspopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
        popover: [{ type: Input, args: ['mdePopoverTriggerFor',] }],
        targetElement: [{ type: Input, args: ['mdePopoverTargetAt',] }],
        positionX: [{ type: Input, args: ['mdePopoverPositionX',] }],
        positionY: [{ type: Input, args: ['mdePopoverPositionY',] }],
        triggerEvent: [{ type: Input, args: ['mdePopoverTriggerOn',] }],
        enterDelay: [{ type: Input, args: ['mdePopoverEnterDelay',] }],
        leaveDelay: [{ type: Input, args: ['mdePopoverLeaveDelay',] }],
        overlapTrigger: [{ type: Input, args: ['mdePopoverOverlapTrigger',] }],
        targetOffsetX: [{ type: Input, args: ['mdePopoverOffsetX',] }],
        targetOffsetY: [{ type: Input, args: ['mdePopoverOffsetY',] }],
        arrowOffsetX: [{ type: Input, args: ['mdePopoverArrowOffsetX',] }],
        arrowWidth: [{ type: Input, args: ['mdePopoverArrowWidth',] }],
        arrowColor: [{ type: Input, args: ['mdePopoverArrowColor',] }],
        closeOnClick: [{ type: Input, args: ['mdePopoverCloseOnClick',] }],
        backdropCloseOnClick: [{ type: Input, args: ['mdePopoverBackdropCloseOnClick',] }],
        opened: [{ type: Output }],
        closed: [{ type: Output }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onMouseEnter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
        onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
        _handleMousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    return MdePopoverTrigger;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MdePopoverTarget = /** @class */ (function () {
    function MdePopoverTarget(_elementRef) {
        this._elementRef = _elementRef;
    }
    MdePopoverTarget.decorators = [
        { type: Directive, args: [{
                    selector: 'mde-popover-target, [mdePopoverTarget]',
                    exportAs: 'mdePopoverTarget'
                },] }
    ];
    /** @nocollapse */
    MdePopoverTarget.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return MdePopoverTarget;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var MdePopoverModule = /** @class */ (function () {
    function MdePopoverModule() {
    }
    MdePopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        OverlayModule,
                        CommonModule,
                        A11yModule
                    ],
                    exports: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                    declarations: [MdePopover, MdePopoverTrigger, MdePopoverTarget],
                },] }
    ];
    return MdePopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { MdePopover, MdePopoverModule, MdePopoverTarget, MdePopoverTrigger, transformPopover };
//# sourceMappingURL=material-extended-mde.js.map
