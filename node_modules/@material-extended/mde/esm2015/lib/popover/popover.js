/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, EventEmitter, Input, Output, TemplateRef, ViewChild, ViewEncapsulation, ElementRef, ChangeDetectionStrategy, HostBinding, NgZone } from '@angular/core';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { throwMdePopoverInvalidPositionX, throwMdePopoverInvalidPositionY } from './popover-errors';
import { transformPopover } from './popover-animations';
export class MdePopover {
    /**
     * @param {?} _elementRef
     * @param {?} zone
     */
    constructor(_elementRef, zone) {
        this._elementRef = _elementRef;
        this.zone = zone;
        // tslint:disable-line:component-class-suffix
        this.role = 'dialog';
        /**
         * Settings for popover, view setters and getters for more detail
         */
        this._positionX = 'after';
        this._positionY = 'below';
        this._triggerEvent = 'hover';
        this._enterDelay = 200;
        this._leaveDelay = 200;
        this._overlapTrigger = true;
        this._disableAnimation = false;
        this._targetOffsetX = 0;
        this._targetOffsetY = 0;
        this._arrowOffsetX = 20;
        this._arrowWidth = 8;
        this._arrowColor = 'rgba(0, 0, 0, 0.12)';
        this._closeOnClick = true;
        this._focusTrapEnabled = true;
        this._focusTrapAutoCaptureEnabled = true;
        /**
         * Config object to be passed into the popover's ngClass
         */
        this._classList = {};
        // TODO: Write comment description
        /**
         *
         */
        this.containerPositioning = false;
        /**
         * Closing disabled on popover
         */
        this.closeDisabled = false;
        /**
         * Emits the current animation state whenever it changes.
         */
        this._onAnimationStateChange = new EventEmitter();
        /**
         * Event emitted when the popover is closed.
         */
        this.close = new EventEmitter();
        this.setPositionClasses();
    }
    /**
     * Position of the popover in the X axis.
     * @return {?}
     */
    get positionX() { return this._positionX; }
    /**
     * @param {?} value
     * @return {?}
     */
    set positionX(value) {
        if (value !== 'before' && value !== 'after') {
            throwMdePopoverInvalidPositionX();
        }
        this._positionX = value;
        this.setPositionClasses();
    }
    /**
     * Position of the popover in the Y axis.
     * @return {?}
     */
    get positionY() { return this._positionY; }
    /**
     * @param {?} value
     * @return {?}
     */
    set positionY(value) {
        if (value !== 'above' && value !== 'below') {
            throwMdePopoverInvalidPositionY();
        }
        this._positionY = value;
        this.setPositionClasses();
    }
    /**
     * Popover trigger event
     * @return {?}
     */
    get triggerEvent() { return this._triggerEvent; }
    /**
     * @param {?} value
     * @return {?}
     */
    set triggerEvent(value) { this._triggerEvent = value; }
    /**
     * Popover enter delay
     * @return {?}
     */
    get enterDelay() { return this._enterDelay; }
    /**
     * @param {?} value
     * @return {?}
     */
    set enterDelay(value) { this._enterDelay = value; }
    /**
     * Popover leave delay
     * @return {?}
     */
    get leaveDelay() { return this._leaveDelay; }
    /**
     * @param {?} value
     * @return {?}
     */
    set leaveDelay(value) { this._leaveDelay = value; }
    /**
     * Popover overlap trigger
     * @return {?}
     */
    get overlapTrigger() { return this._overlapTrigger; }
    /**
     * @param {?} value
     * @return {?}
     */
    set overlapTrigger(value) { this._overlapTrigger = value; }
    /**
     * Popover target offset x
     * @return {?}
     */
    get targetOffsetX() { return this._targetOffsetX; }
    /**
     * @param {?} value
     * @return {?}
     */
    set targetOffsetX(value) { this._targetOffsetX = value; }
    /**
     * Popover target offset y
     * @return {?}
     */
    get targetOffsetY() { return this._targetOffsetY; }
    /**
     * @param {?} value
     * @return {?}
     */
    set targetOffsetY(value) { this._targetOffsetY = value; }
    /**
     * Popover arrow offset x
     * @return {?}
     */
    get arrowOffsetX() { return this._arrowOffsetX; }
    /**
     * @param {?} value
     * @return {?}
     */
    set arrowOffsetX(value) { this._arrowOffsetX = value; }
    /**
     * Popover arrow width
     * @return {?}
     */
    get arrowWidth() { return this._arrowWidth; }
    /**
     * @param {?} value
     * @return {?}
     */
    set arrowWidth(value) { this._arrowWidth = value; }
    /**
     * Popover arrow color
     * @return {?}
     */
    get arrowColor() { return this._arrowColor; }
    /**
     * @param {?} value
     * @return {?}
     */
    set arrowColor(value) { this._arrowColor = value; }
    /**
     * Popover container close on click
     * default: true
     * @return {?}
     */
    get closeOnClick() { return this._closeOnClick; }
    /**
     * @param {?} value
     * @return {?}
     */
    set closeOnClick(value) { this._closeOnClick = coerceBooleanProperty(value); }
    /**
     * Disable animations of popover and all child elements
     * default: false
     * @return {?}
     */
    get disableAnimation() { return this._disableAnimation; }
    /**
     * @param {?} value
     * @return {?}
     */
    set disableAnimation(value) { this._disableAnimation = coerceBooleanProperty(value); }
    /**
     * Popover focus trap using cdkTrapFocus
     * default: true
     * @return {?}
     */
    get focusTrapEnabled() { return this._focusTrapEnabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set focusTrapEnabled(value) { this._focusTrapEnabled = coerceBooleanProperty(value); }
    /**
     * Popover focus trap auto capture using cdkTrapFocusAutoCapture
     * default: true
     * @return {?}
     */
    get focusTrapAutoCaptureEnabled() { return this._focusTrapAutoCaptureEnabled; }
    /**
     * @param {?} value
     * @return {?}
     */
    set focusTrapAutoCaptureEnabled(value) { this._focusTrapAutoCaptureEnabled = coerceBooleanProperty(value); }
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @param {?} classes list of class names
     * @return {?}
     */
    set panelClass(classes) {
        if (classes && classes.length) {
            this._classList = classes.split(' ').reduce((/**
             * @param {?} obj
             * @param {?} className
             * @return {?}
             */
            (obj, className) => {
                obj[className] = true;
                return obj;
            }), {});
            this._elementRef.nativeElement.className = '';
            this.setPositionClasses();
        }
    }
    /**
     * This method takes classes set on the host md-popover element and applies them on the
     * popover template that displays in the overlay container.  Otherwise, it's difficult
     * to style the containing popover from outside the component.
     * @deprecated Use `panelClass` instead.
     * @return {?}
     */
    get classList() { return this.panelClass; }
    /**
     * @param {?} classes
     * @return {?}
     */
    set classList(classes) { this.panelClass = classes; }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._emitCloseEvent();
        this.close.complete();
    }
    /**
     * Handle a keyboard event from the popover, delegating to the appropriate action.
     * @param {?} event
     * @return {?}
     */
    _handleKeydown(event) {
        switch (event.keyCode) {
            case ESCAPE:
                this._emitCloseEvent();
                return;
        }
    }
    /**
     * This emits a close event to which the trigger is subscribed. When emitted, the
     * trigger will close the popover.
     * @return {?}
     */
    _emitCloseEvent() {
        this.close.emit();
    }
    /**
     * Close popover on click if closeOnClick is true
     * @return {?}
     */
    onClick() {
        if (this.closeOnClick) {
            this._emitCloseEvent();
        }
    }
    /**
       * TODO: Refactor when @angular/cdk includes feature I mentioned on github see link below.
       * https://github.com/angular/material2/pull/5493#issuecomment-313085323
       */
    /**
     * Disables close of popover when leaving trigger element and mouse over the popover
     * @return {?}
     */
    onMouseOver() {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = true;
        }
    }
    /**
     * Enables close of popover when mouse leaving popover element
     * @return {?}
     */
    onMouseLeave() {
        if (this.triggerEvent === 'hover') {
            this.closeDisabled = false;
            this._emitCloseEvent();
        }
    }
    // TODO: Refactor how styles are set and updated on the component, use best practices.
    // TODO: If arrow left and right positioning is requested, see if flex direction can be used to work with order.
    /**
     * Sets the current styles for the popover to allow for dynamically changing settings
     * @return {?}
     */
    setCurrentStyles() {
        // TODO: See if arrow position can be calculated automatically and allow override.
        // TODO: See if flex order is a better alternative to position arrow top or bottom.
        this.popoverArrowStyles = {
            'right': this.positionX === 'before' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'left': this.positionX === 'after' ? (this.arrowOffsetX - this.arrowWidth) + 'px' : '',
            'border-top': this.positionY === 'below' ?
                this.arrowWidth + 'px solid ' + this.arrowColor : '0px solid transparent',
            'border-right': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-bottom': this.positionY === 'above' ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
            'border-left': 'undefined' === undefined ?
                this.arrowWidth + 'px solid ' + this.arrowColor :
                this.arrowWidth + 'px solid transparent',
        };
        // TODO: Remove if flex order is added.
        this.popoverContentStyles = {
            'padding-top': this.overlapTrigger === true ? '0px' : this.arrowWidth + 'px',
            'padding-bottom': this.overlapTrigger === true ? '0px' : (this.arrowWidth) + 'px',
            'margin-top': this.overlapTrigger === false && this.positionY === 'below' && this.containerPositioning === false ?
                -(this.arrowWidth * 2) + 'px' : '0px'
        };
    }
    /**
     * It's necessary to set position-based classes to ensure the popover panel animation
     * folds out from the correct direction.
     * @param {?=} posX
     * @param {?=} posY
     * @return {?}
     */
    setPositionClasses(posX = this.positionX, posY = this.positionY) {
        this._classList['mde-popover-before'] = posX === 'before';
        this._classList['mde-popover-after'] = posX === 'after';
        this._classList['mde-popover-above'] = posY === 'above';
        this._classList['mde-popover-below'] = posY === 'below';
    }
}
MdePopover.decorators = [
    { type: Component, args: [{
                selector: 'mde-popover',
                template: "<ng-template>\r\n  <div class=\"mde-popover-panel\" role=\"dialog\" [class.mde-popover-overlap]=\"overlapTrigger\"\r\n       [ngClass]=\"_classList\" [ngStyle]=\"popoverPanelStyles\" (keydown)=\"_handleKeydown($event)\"\r\n       (click)=\"onClick()\" (mouseover)=\"onMouseOver()\" (mouseleave)=\"onMouseLeave()\" [@.disabled]=\"disableAnimation\"\r\n       [@transformPopover]=\"'enter'\">\r\n    <div class=\"mde-popover-direction-arrow\" [ngStyle]=\"popoverArrowStyles\" *ngIf=\"!overlapTrigger\"></div>\r\n    <div class=\"mde-popover-content\" [ngStyle]=\"popoverContentStyles\" [cdkTrapFocus]=\"focusTrapEnabled\" [cdkTrapFocusAutoCapture]=\"focusTrapAutoCaptureEnabled\">\r\n      <ng-content></ng-content>\r\n    </div>\r\n  </div>\r\n</ng-template>\r\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                animations: [
                    transformPopover
                ],
                exportAs: 'mdePopover',
                styles: [".mde-popover-panel{display:flex;flex-direction:column;max-height:calc(100vh + 48px)}.mde-popover-ripple{position:absolute;top:0;left:0;bottom:0;right:0}.mde-popover-below .mde-popover-direction-arrow{position:absolute;bottom:0;width:0;height:0;border-bottom-width:0!important;z-index:99999}.mde-popover-above .mde-popover-direction-arrow{position:absolute;top:0;width:0;height:0;border-top-width:0!important;z-index:99999}.mde-popover-after .mde-popover-direction-arrow{left:20px}.mde-popover-before .mde-popover-direction-arrow{right:20px}"]
            }] }
];
/** @nocollapse */
MdePopover.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
MdePopover.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.role',] }],
    positionX: [{ type: Input, args: ['mdePopoverPositionX',] }],
    positionY: [{ type: Input, args: ['mdePopoverPositionY',] }],
    triggerEvent: [{ type: Input, args: ['mdePopoverTriggerOn',] }],
    enterDelay: [{ type: Input, args: ['mdePopoverEnterDelay',] }],
    leaveDelay: [{ type: Input, args: ['mdePopoverLeaveDelay',] }],
    overlapTrigger: [{ type: Input, args: ['mdePopoverOverlapTrigger',] }],
    targetOffsetX: [{ type: Input, args: ['mdePopoverOffsetX',] }],
    targetOffsetY: [{ type: Input, args: ['mdePopoverOffsetY',] }],
    arrowOffsetX: [{ type: Input, args: ['mdePopoverArrowOffsetX',] }],
    arrowWidth: [{ type: Input, args: ['mdePopoverArrowWidth',] }],
    arrowColor: [{ type: Input, args: ['mdePopoverArrowColor',] }],
    closeOnClick: [{ type: Input, args: ['mdePopoverCloseOnClick',] }],
    disableAnimation: [{ type: Input, args: ['mdePopoverDisableAnimation',] }],
    focusTrapEnabled: [{ type: Input, args: ['mdeFocusTrapEnabled',] }],
    focusTrapAutoCaptureEnabled: [{ type: Input, args: ['mdeFocusTrapAutoCaptureEnabled',] }],
    panelClass: [{ type: Input, args: ['class',] }],
    classList: [{ type: Input }],
    close: [{ type: Output }],
    templateRef: [{ type: ViewChild, args: [TemplateRef, { static: false },] }]
};
if (false) {
    /** @type {?} */
    MdePopover.prototype.role;
    /**
     * Settings for popover, view setters and getters for more detail
     * @type {?}
     * @private
     */
    MdePopover.prototype._positionX;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._positionY;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._triggerEvent;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._enterDelay;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._leaveDelay;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._overlapTrigger;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._disableAnimation;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._targetOffsetX;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._targetOffsetY;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._arrowOffsetX;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._arrowWidth;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._arrowColor;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._closeOnClick;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._focusTrapEnabled;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._focusTrapAutoCaptureEnabled;
    /**
     * Config object to be passed into the popover's ngClass
     * @type {?}
     */
    MdePopover.prototype._classList;
    /**
     *
     * @type {?}
     */
    MdePopover.prototype.containerPositioning;
    /**
     * Closing disabled on popover
     * @type {?}
     */
    MdePopover.prototype.closeDisabled;
    /**
     * Config object to be passed into the popover's arrow ngStyle
     * @type {?}
     */
    MdePopover.prototype.popoverPanelStyles;
    /**
     * Config object to be passed into the popover's arrow ngStyle
     * @type {?}
     */
    MdePopover.prototype.popoverArrowStyles;
    /**
     * Config object to be passed into the popover's content ngStyle
     * @type {?}
     */
    MdePopover.prototype.popoverContentStyles;
    /**
     * Emits the current animation state whenever it changes.
     * @type {?}
     */
    MdePopover.prototype._onAnimationStateChange;
    /**
     * Event emitted when the popover is closed.
     * @type {?}
     */
    MdePopover.prototype.close;
    /** @type {?} */
    MdePopover.prototype.templateRef;
    /**
     * @type {?}
     * @private
     */
    MdePopover.prototype._elementRef;
    /** @type {?} */
    MdePopover.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BtYXRlcmlhbC1leHRlbmRlZC9tZGUvIiwic291cmNlcyI6WyJsaWIvcG9wb3Zlci9wb3BvdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBRUwsTUFBTSxFQUNOLFdBQVcsRUFDWCxTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLFVBQVUsRUFDVix1QkFBdUIsRUFDdkIsV0FBVyxFQUNYLE1BQU0sRUFDUCxNQUFNLGVBQWUsQ0FBQztBQUl2QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFHL0MsT0FBTyxFQUFFLCtCQUErQixFQUFFLCtCQUErQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFFcEcsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFheEQsTUFBTSxPQUFPLFVBQVU7Ozs7O0lBaUxyQixZQUFvQixXQUF1QixFQUFTLElBQVk7UUFBNUMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFBUyxTQUFJLEdBQUosSUFBSSxDQUFROztRQS9LdEMsU0FBSSxHQUFHLFFBQVEsQ0FBQzs7OztRQUdsQyxlQUFVLEdBQXdCLE9BQU8sQ0FBQztRQUMxQyxlQUFVLEdBQXdCLE9BQU8sQ0FBQztRQUMxQyxrQkFBYSxHQUEyQixPQUFPLENBQUM7UUFDaEQsZ0JBQVcsR0FBRyxHQUFHLENBQUM7UUFDbEIsZ0JBQVcsR0FBRyxHQUFHLENBQUM7UUFDbEIsb0JBQWUsR0FBRyxJQUFJLENBQUM7UUFDdkIsc0JBQWlCLEdBQUcsS0FBSyxDQUFDO1FBQzFCLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLG1CQUFjLEdBQUcsQ0FBQyxDQUFDO1FBQ25CLGtCQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ25CLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLGdCQUFXLEdBQUcscUJBQXFCLENBQUM7UUFDcEMsa0JBQWEsR0FBRyxJQUFJLENBQUM7UUFDckIsc0JBQWlCLEdBQUcsSUFBSSxDQUFDO1FBQ3pCLGlDQUE0QixHQUFHLElBQUksQ0FBQzs7OztRQUc1QyxlQUFVLEdBQTZCLEVBQUUsQ0FBQzs7Ozs7UUFJbkMseUJBQW9CLEdBQUcsS0FBSyxDQUFDOzs7O1FBRzdCLGtCQUFhLEdBQUcsS0FBSyxDQUFDOzs7O1FBWTdCLDRCQUF1QixHQUFHLElBQUksWUFBWSxFQUFrQixDQUFDOzs7O1FBb0luRCxVQUFLLEdBQUcsSUFBSSxZQUFZLEVBQVEsQ0FBQztRQUt6QyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUM1QixDQUFDOzs7OztJQXRJRCxJQUNJLFNBQVMsS0FBSyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDOzs7OztJQUMzQyxJQUFJLFNBQVMsQ0FBQyxLQUEwQjtRQUN0QyxJQUFJLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxLQUFLLE9BQU8sRUFBRTtZQUMzQywrQkFBK0IsRUFBRSxDQUFDO1NBQ25DO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7SUFDNUIsQ0FBQzs7Ozs7SUFHRCxJQUNJLFNBQVMsS0FBSyxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDOzs7OztJQUMzQyxJQUFJLFNBQVMsQ0FBQyxLQUEwQjtRQUN0QyxJQUFJLEtBQUssS0FBSyxPQUFPLElBQUksS0FBSyxLQUFLLE9BQU8sRUFBRTtZQUMxQywrQkFBK0IsRUFBRSxDQUFDO1NBQ25DO1FBQ0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7UUFDeEIsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7SUFDNUIsQ0FBQzs7Ozs7SUFHRCxJQUNJLFlBQVksS0FBNkIsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQzs7Ozs7SUFDekUsSUFBSSxZQUFZLENBQUMsS0FBNkIsSUFBSSxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBRy9FLElBQ0ksVUFBVSxLQUFhLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBQ3JELElBQUksVUFBVSxDQUFDLEtBQWEsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBRzNELElBQ0ksVUFBVSxLQUFhLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBQ3JELElBQUksVUFBVSxDQUFDLEtBQWEsSUFBSSxJQUFJLENBQUMsV0FBVyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBRzNELElBQ0ksY0FBYyxLQUFjLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBQzlELElBQUksY0FBYyxDQUFDLEtBQWMsSUFBSSxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBR3BFLElBQ0ksYUFBYSxLQUFhLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBQzNELElBQUksYUFBYSxDQUFDLEtBQWEsSUFBSSxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBR2pFLElBQ0ksYUFBYSxLQUFhLE9BQU8sSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBQzNELElBQUksYUFBYSxDQUFDLEtBQWEsSUFBSSxJQUFJLENBQUMsY0FBYyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBR2pFLElBQ0ksWUFBWSxLQUFhLE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Ozs7O0lBQ3pELElBQUksWUFBWSxDQUFDLEtBQWEsSUFBSSxJQUFJLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUM7Ozs7O0lBRy9ELElB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OztJQUN4RCxpQ0FBMEI7Ozs7O0lBQzFCLGlDQUEwQjs7Ozs7SUFDMUIscUNBQStCOzs7OztJQUMvQix1Q0FBa0M7Ozs7O0lBQ2xDLG9DQUEyQjs7Ozs7SUFDM0Isb0NBQTJCOzs7OztJQUMzQixtQ0FBMkI7Ozs7O0lBQzNCLGlDQUF3Qjs7Ozs7SUFDeEIsaUNBQTRDOzs7OztJQUM1QyxtQ0FBNkI7Ozs7O0lBQzdCLHVDQUFpQzs7Ozs7SUFDakMsa0RBQTRDOzs7OztJQUc1QyxnQ0FBMEM7Ozs7O0lBSTFDLDBDQUFvQzs7Ozs7SUFHcEMsbUNBQTZCOzs7OztJQUc3Qix3Q0FBOEI7Ozs7O0lBRzlCLHdDQUE4Qjs7Ozs7SUFHOUIsMENBQWdDOzs7OztJQUdoQyw2Q0FBNkQ7Ozs7O0lBb0k3RCwyQkFBMkM7O0lBRTNDLGlDQUF5RTs7Ozs7SUFFN0QsaUNBQStCOztJQUFFLDBCQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ29tcG9uZW50LFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT3V0cHV0LFxyXG4gIFRlbXBsYXRlUmVmLFxyXG4gIFZpZXdDaGlsZCxcclxuICBWaWV3RW5jYXBzdWxhdGlvbixcclxuICBFbGVtZW50UmVmLFxyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIEhvc3RCaW5kaW5nLFxyXG4gIE5nWm9uZVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgQW5pbWF0aW9uRXZlbnQgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcclxuXHJcbmltcG9ydCB7IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XHJcbmltcG9ydCB7IEVTQ0FQRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XHJcblxyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUG9zaXRpb25YLCBNZGVQb3BvdmVyUG9zaXRpb25ZLCBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50IH0gZnJvbSAnLi9wb3BvdmVyLXR5cGVzJztcclxuaW1wb3J0IHsgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCwgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWSB9IGZyb20gJy4vcG9wb3Zlci1lcnJvcnMnO1xyXG5pbXBvcnQgeyBNZGVQb3BvdmVyUGFuZWwgfSBmcm9tICcuL3BvcG92ZXItaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IHRyYW5zZm9ybVBvcG92ZXIgfSBmcm9tICcuL3BvcG92ZXItYW5pbWF0aW9ucyc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ21kZS1wb3BvdmVyJyxcclxuICB0ZW1wbGF0ZVVybDogJy4vcG9wb3Zlci5odG1sJyxcclxuICBzdHlsZVVybHM6IFsnLi9wb3BvdmVyLnNjc3MnXSxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxuICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxyXG4gIGFuaW1hdGlvbnM6IFtcclxuICAgIHRyYW5zZm9ybVBvcG92ZXJcclxuICBdLFxyXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlcidcclxufSlcclxuZXhwb3J0IGNsYXNzIE1kZVBvcG92ZXIgaW1wbGVtZW50cyBNZGVQb3BvdmVyUGFuZWwsIE9uRGVzdHJveSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6Y29tcG9uZW50LWNsYXNzLXN1ZmZpeFxyXG5cclxuICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpIHJvbGUgPSAnZGlhbG9nJztcclxuXHJcbiAgLyoqIFNldHRpbmdzIGZvciBwb3BvdmVyLCB2aWV3IHNldHRlcnMgYW5kIGdldHRlcnMgZm9yIG1vcmUgZGV0YWlsICovXHJcbiAgcHJpdmF0ZSBfcG9zaXRpb25YOiBNZGVQb3BvdmVyUG9zaXRpb25YID0gJ2FmdGVyJztcclxuICBwcml2YXRlIF9wb3NpdGlvblk6IE1kZVBvcG92ZXJQb3NpdGlvblkgPSAnYmVsb3cnO1xyXG4gIHByaXZhdGUgX3RyaWdnZXJFdmVudDogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCA9ICdob3Zlcic7XHJcbiAgcHJpdmF0ZSBfZW50ZXJEZWxheSA9IDIwMDtcclxuICBwcml2YXRlIF9sZWF2ZURlbGF5ID0gMjAwO1xyXG4gIHByaXZhdGUgX292ZXJsYXBUcmlnZ2VyID0gdHJ1ZTtcclxuICBwcml2YXRlIF9kaXNhYmxlQW5pbWF0aW9uID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WCA9IDA7XHJcbiAgcHJpdmF0ZSBfdGFyZ2V0T2Zmc2V0WSA9IDA7XHJcbiAgcHJpdmF0ZSBfYXJyb3dPZmZzZXRYID0gMjA7XHJcbiAgcHJpdmF0ZSBfYXJyb3dXaWR0aCA9IDg7XHJcbiAgcHJpdmF0ZSBfYXJyb3dDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuMTIpJztcclxuICBwcml2YXRlIF9jbG9zZU9uQ2xpY2sgPSB0cnVlO1xyXG4gIHByaXZhdGUgX2ZvY3VzVHJhcEVuYWJsZWQgPSB0cnVlO1xyXG4gIHByaXZhdGUgX2ZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZCA9IHRydWU7XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgbmdDbGFzcyAqL1xyXG4gIF9jbGFzc0xpc3Q6IHtba2V5OiBzdHJpbmddOiBib29sZWFufSA9IHt9O1xyXG5cclxuICAvLyBUT0RPOiBXcml0ZSBjb21tZW50IGRlc2NyaXB0aW9uXHJcbiAgLyoqICovXHJcbiAgcHVibGljIGNvbnRhaW5lclBvc2l0aW9uaW5nID0gZmFsc2U7XHJcblxyXG4gIC8qKiBDbG9zaW5nIGRpc2FibGVkIG9uIHBvcG92ZXIgKi9cclxuICBwdWJsaWMgY2xvc2VEaXNhYmxlZCA9IGZhbHNlO1xyXG5cclxuICAvKiogQ29uZmlnIG9iamVjdCB0byBiZSBwYXNzZWQgaW50byB0aGUgcG9wb3ZlcidzIGFycm93IG5nU3R5bGUgKi9cclxuICBwdWJsaWMgcG9wb3ZlclBhbmVsU3R5bGVzOiB7fTtcclxuXHJcbiAgLyoqIENvbmZpZyBvYmplY3QgdG8gYmUgcGFzc2VkIGludG8gdGhlIHBvcG92ZXIncyBhcnJvdyBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJBcnJvd1N0eWxlczoge307XHJcblxyXG4gIC8qKiBDb25maWcgb2JqZWN0IHRvIGJlIHBhc3NlZCBpbnRvIHRoZSBwb3BvdmVyJ3MgY29udGVudCBuZ1N0eWxlICovXHJcbiAgcHVibGljIHBvcG92ZXJDb250ZW50U3R5bGVzOiB7fTtcclxuXHJcbiAgLyoqIEVtaXRzIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSB3aGVuZXZlciBpdCBjaGFuZ2VzLiAqL1xyXG4gIF9vbkFuaW1hdGlvblN0YXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxBbmltYXRpb25FdmVudD4oKTtcclxuXHJcblxyXG4gIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWCBheGlzLiAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlclBvc2l0aW9uWCcpXHJcbiAgZ2V0IHBvc2l0aW9uWCgpIHsgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uWDsgfVxyXG4gIHNldCBwb3NpdGlvblgodmFsdWU6IE1kZVBvcG92ZXJQb3NpdGlvblgpIHtcclxuICAgIGlmICh2YWx1ZSAhPT0gJ2JlZm9yZScgJiYgdmFsdWUgIT09ICdhZnRlcicpIHtcclxuICAgICAgdGhyb3dNZGVQb3BvdmVySW52YWxpZFBvc2l0aW9uWCgpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fcG9zaXRpb25YID0gdmFsdWU7XHJcbiAgICB0aGlzLnNldFBvc2l0aW9uQ2xhc3NlcygpO1xyXG4gIH1cclxuXHJcbiAgLyoqIFBvc2l0aW9uIG9mIHRoZSBwb3BvdmVyIGluIHRoZSBZIGF4aXMuICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25ZJylcclxuICBnZXQgcG9zaXRpb25ZKCkgeyByZXR1cm4gdGhpcy5fcG9zaXRpb25ZOyB9XHJcbiAgc2V0IHBvc2l0aW9uWSh2YWx1ZTogTWRlUG9wb3ZlclBvc2l0aW9uWSkge1xyXG4gICAgaWYgKHZhbHVlICE9PSAnYWJvdmUnICYmIHZhbHVlICE9PSAnYmVsb3cnKSB7XHJcbiAgICAgIHRocm93TWRlUG9wb3ZlckludmFsaWRQb3NpdGlvblkoKTtcclxuICAgIH1cclxuICAgIHRoaXMuX3Bvc2l0aW9uWSA9IHZhbHVlO1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIHRyaWdnZXIgZXZlbnQgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJUcmlnZ2VyT24nKVxyXG4gIGdldCB0cmlnZ2VyRXZlbnQoKTogTWRlUG9wb3ZlclRyaWdnZXJFdmVudCB7IHJldHVybiB0aGlzLl90cmlnZ2VyRXZlbnQ7IH1cclxuICBzZXQgdHJpZ2dlckV2ZW50KHZhbHVlOiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50KSB7IHRoaXMuX3RyaWdnZXJFdmVudCA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGVudGVyIGRlbGF5ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyRW50ZXJEZWxheScpXHJcbiAgZ2V0IGVudGVyRGVsYXkoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX2VudGVyRGVsYXk7IH1cclxuICBzZXQgZW50ZXJEZWxheSh2YWx1ZTogbnVtYmVyKSB7IHRoaXMuX2VudGVyRGVsYXkgPSB2YWx1ZTsgfVxyXG5cclxuICAvKiogUG9wb3ZlciBsZWF2ZSBkZWxheSAqL1xyXG4gIEBJbnB1dCgnbWRlUG9wb3ZlckxlYXZlRGVsYXknKVxyXG4gIGdldCBsZWF2ZURlbGF5KCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9sZWF2ZURlbGF5OyB9XHJcbiAgc2V0IGxlYXZlRGVsYXkodmFsdWU6IG51bWJlcikgeyB0aGlzLl9sZWF2ZURlbGF5ID0gdmFsdWU7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgb3ZlcmxhcCB0cmlnZ2VyICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyT3ZlcmxhcFRyaWdnZXInKVxyXG4gIGdldCBvdmVybGFwVHJpZ2dlcigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX292ZXJsYXBUcmlnZ2VyOyB9XHJcbiAgc2V0IG92ZXJsYXBUcmlnZ2VyKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX292ZXJsYXBUcmlnZ2VyID0gdmFsdWU7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB4ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyT2Zmc2V0WCcpXHJcbiAgZ2V0IHRhcmdldE9mZnNldFgoKTogbnVtYmVyIHsgcmV0dXJuIHRoaXMuX3RhcmdldE9mZnNldFg7IH1cclxuICBzZXQgdGFyZ2V0T2Zmc2V0WCh2YWx1ZTogbnVtYmVyKSB7IHRoaXMuX3RhcmdldE9mZnNldFggPSB2YWx1ZTsgfVxyXG5cclxuICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHkgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRZJylcclxuICBnZXQgdGFyZ2V0T2Zmc2V0WSgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fdGFyZ2V0T2Zmc2V0WTsgfVxyXG4gIHNldCB0YXJnZXRPZmZzZXRZKHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fdGFyZ2V0T2Zmc2V0WSA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IG9mZnNldCB4ICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dPZmZzZXRYJylcclxuICBnZXQgYXJyb3dPZmZzZXRYKCk6IG51bWJlciB7IHJldHVybiB0aGlzLl9hcnJvd09mZnNldFg7IH1cclxuICBzZXQgYXJyb3dPZmZzZXRYKHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fYXJyb3dPZmZzZXRYID0gdmFsdWU7IH1cclxuXHJcbiAgLyoqIFBvcG92ZXIgYXJyb3cgd2lkdGggKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd1dpZHRoJylcclxuICBnZXQgYXJyb3dXaWR0aCgpOiBudW1iZXIgeyByZXR1cm4gdGhpcy5fYXJyb3dXaWR0aDsgfVxyXG4gIHNldCBhcnJvd1dpZHRoKHZhbHVlOiBudW1iZXIpIHsgdGhpcy5fYXJyb3dXaWR0aCA9IHZhbHVlOyB9XHJcblxyXG4gIC8qKiBQb3BvdmVyIGFycm93IGNvbG9yICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyQXJyb3dDb2xvcicpXHJcbiAgZ2V0IGFycm93Q29sb3IoKTogc3RyaW5nIHsgcmV0dXJuIHRoaXMuX2Fycm93Q29sb3I7IH1cclxuICBzZXQgYXJyb3dDb2xvcih2YWx1ZTogc3RyaW5nKSB7IHRoaXMuX2Fycm93Q29sb3IgPSB2YWx1ZTsgfVxyXG5cclxuICAvKipcclxuICAgKiBQb3BvdmVyIGNvbnRhaW5lciBjbG9zZSBvbiBjbGlja1xyXG4gICAqIGRlZmF1bHQ6IHRydWVcclxuICAgKi9cclxuICBASW5wdXQoJ21kZVBvcG92ZXJDbG9zZU9uQ2xpY2snKVxyXG4gIGdldCBjbG9zZU9uQ2xpY2soKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9jbG9zZU9uQ2xpY2s7IH1cclxuICBzZXQgY2xvc2VPbkNsaWNrKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2Nsb3NlT25DbGljayA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzYWJsZSBhbmltYXRpb25zIG9mIHBvcG92ZXIgYW5kIGFsbCBjaGlsZCBlbGVtZW50c1xyXG4gICAqIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICovXHJcbiAgQElucHV0KCdtZGVQb3BvdmVyRGlzYWJsZUFuaW1hdGlvbicpXHJcbiAgZ2V0IGRpc2FibGVBbmltYXRpb24oKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9kaXNhYmxlQW5pbWF0aW9uOyB9XHJcbiAgc2V0IGRpc2FibGVBbmltYXRpb24odmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fZGlzYWJsZUFuaW1hdGlvbiA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogUG9wb3ZlciBmb2N1cyB0cmFwIHVzaW5nIGNka1RyYXBGb2N1c1xyXG4gICAqIGRlZmF1bHQ6IHRydWVcclxuICAgKi9cclxuICBASW5wdXQoJ21kZUZvY3VzVHJhcEVuYWJsZWQnKVxyXG4gIGdldCBmb2N1c1RyYXBFbmFibGVkKCk6IGJvb2xlYW4geyByZXR1cm4gdGhpcy5fZm9jdXNUcmFwRW5hYmxlZDsgfVxyXG4gIHNldCBmb2N1c1RyYXBFbmFibGVkKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2ZvY3VzVHJhcEVuYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpOyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBvcG92ZXIgZm9jdXMgdHJhcCBhdXRvIGNhcHR1cmUgdXNpbmcgY2RrVHJhcEZvY3VzQXV0b0NhcHR1cmVcclxuICAgKiBkZWZhdWx0OiB0cnVlXHJcbiAgICovXHJcbiAgQElucHV0KCdtZGVGb2N1c1RyYXBBdXRvQ2FwdHVyZUVuYWJsZWQnKVxyXG4gIGdldCBmb2N1c1RyYXBBdXRvQ2FwdHVyZUVuYWJsZWQoKTogYm9vbGVhbiB7IHJldHVybiB0aGlzLl9mb2N1c1RyYXBBdXRvQ2FwdHVyZUVuYWJsZWQ7IH1cclxuICBzZXQgZm9jdXNUcmFwQXV0b0NhcHR1cmVFbmFibGVkKHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX2ZvY3VzVHJhcEF1dG9DYXB0dXJlRW5hYmxlZCA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7IH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBtZXRob2QgdGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbWQtcG9wb3ZlciBlbGVtZW50IGFuZCBhcHBsaWVzIHRoZW0gb24gdGhlXHJcbiAgICogcG9wb3ZlciB0ZW1wbGF0ZSB0aGF0IGRpc3BsYXlzIGluIHRoZSBvdmVybGF5IGNvbnRhaW5lci4gIE90aGVyd2lzZSwgaXQncyBkaWZmaWN1bHRcclxuICAgKiB0byBzdHlsZSB0aGUgY29udGFpbmluZyBwb3BvdmVyIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LlxyXG4gICAqIEBwYXJhbSBjbGFzc2VzIGxpc3Qgb2YgY2xhc3MgbmFtZXNcclxuICAgKi9cclxuICBASW5wdXQoJ2NsYXNzJylcclxuICBzZXQgcGFuZWxDbGFzcyhjbGFzc2VzOiBzdHJpbmcpIHtcclxuICAgIGlmIChjbGFzc2VzICYmIGNsYXNzZXMubGVuZ3RoKSB7XHJcbiAgICAgIHRoaXMuX2NsYXNzTGlzdCA9IGNsYXNzZXMuc3BsaXQoJyAnKS5yZWR1Y2UoKG9iajogYW55LCBjbGFzc05hbWU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIG9ialtjbGFzc05hbWVdID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICB9LCB7fSk7XHJcblxyXG4gICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XHJcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25DbGFzc2VzKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBjbGFzc2VzIHNldCBvbiB0aGUgaG9zdCBtZC1wb3BvdmVyIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSBvbiB0aGVcclxuICAgKiBwb3BvdmVyIHRlbXBsYXRlIHRoYXQgZGlzcGxheXMgaW4gdGhlIG92ZXJsYXkgY29udGFpbmVyLiAgT3RoZXJ3aXNlLCBpdCdzIGRpZmZpY3VsdFxyXG4gICAqIHRvIHN0eWxlIHRoZSBjb250YWluaW5nIHBvcG92ZXIgZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQuXHJcbiAgICogQGRlcHJlY2F0ZWQgVXNlIGBwYW5lbENsYXNzYCBpbnN0ZWFkLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgZ2V0IGNsYXNzTGlzdCgpOiBzdHJpbmcgeyByZXR1cm4gdGhpcy5wYW5lbENsYXNzOyB9XHJcbiAgc2V0IGNsYXNzTGlzdChjbGFzc2VzOiBzdHJpbmcpIHsgdGhpcy5wYW5lbENsYXNzID0gY2xhc3NlczsgfVxyXG5cclxuICAvKiogRXZlbnQgZW1pdHRlZCB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZC4gKi9cclxuICBAT3V0cHV0KCkgY2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XHJcblxyXG4gIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYsIHsgc3RhdGljOiBmYWxzZSB9KSB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHVibGljIHpvbmU6IE5nWm9uZSkge1xyXG4gICAgdGhpcy5zZXRQb3NpdGlvbkNsYXNzZXMoKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgIHRoaXMuY2xvc2UuY29tcGxldGUoKTtcclxuICB9XHJcblxyXG5cclxuICAvKiogSGFuZGxlIGEga2V5Ym9hcmQgZXZlbnQgZnJvbSB0aGUgcG9wb3ZlciwgZGVsZWdhdGluZyB0byB0aGUgYXBwcm9wcmlhdGUgYWN0aW9uLiAqL1xyXG4gIF9oYW5kbGVLZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XHJcbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcclxuICAgICAgY2FzZSBFU0NBUEU6XHJcbiAgICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIGVtaXRzIGEgY2xvc2UgZXZlbnQgdG8gd2hpY2ggdGhlIHRyaWdnZXIgaXMgc3Vic2NyaWJlZC4gV2hlbiBlbWl0dGVkLCB0aGVcclxuICAgKiB0cmlnZ2VyIHdpbGwgY2xvc2UgdGhlIHBvcG92ZXIuXHJcbiAgICovXHJcbiAgX2VtaXRDbG9zZUV2ZW50KCk6IHZvaWQge1xyXG4gICAgdGhpcy5jbG9zZS5lbWl0KCk7XHJcbiAgfVxyXG5cclxuICAvKiogQ2xvc2UgcG9wb3ZlciBvbiBjbGljayBpZiBjbG9zZU9uQ2xpY2sgaXMgdHJ1ZSAqL1xyXG4gIG9uQ2xpY2soKSB7XHJcbiAgICBpZiAodGhpcy5jbG9zZU9uQ2xpY2spIHtcclxuICAgICAgdGhpcy5fZW1pdENsb3NlRXZlbnQoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRPRE86IFJlZmFjdG9yIHdoZW4gQGFuZ3VsYXIvY2RrIGluY2x1ZGVzIGZlYXR1cmUgSSBtZW50aW9uZWQgb24gZ2l0aHViIHNlZSBsaW5rIGJlbG93LlxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL21hdGVyaWFsMi9wdWxsLzU0OTMjaXNzdWVjb21tZW50LTMxMzA4NTMyM1xyXG4gICAqL1xyXG4gIC8qKiBEaXNhYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbGVhdmluZyB0cmlnZ2VyIGVsZW1lbnQgYW5kIG1vdXNlIG92ZXIgdGhlIHBvcG92ZXIgKi9cclxuICBvbk1vdXNlT3ZlcigpIHtcclxuICAgIGlmICh0aGlzLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICB0aGlzLmNsb3NlRGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH1cclxuICAvKiogRW5hYmxlcyBjbG9zZSBvZiBwb3BvdmVyIHdoZW4gbW91c2UgbGVhdmluZyBwb3BvdmVyIGVsZW1lbnQgKi9cclxuICBvbk1vdXNlTGVhdmUoKSB7XHJcbiAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcclxuICAgICAgdGhpcy5jbG9zZURpc2FibGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBSZWZhY3RvciBob3cgc3R5bGVzIGFyZSBzZXQgYW5kIHVwZGF0ZWQgb24gdGhlIGNvbXBvbmVudCwgdXNlIGJlc3QgcHJhY3RpY2VzLlxyXG4gIC8vIFRPRE86IElmIGFycm93IGxlZnQgYW5kIHJpZ2h0IHBvc2l0aW9uaW5nIGlzIHJlcXVlc3RlZCwgc2VlIGlmIGZsZXggZGlyZWN0aW9uIGNhbiBiZSB1c2VkIHRvIHdvcmsgd2l0aCBvcmRlci5cclxuICAvKiogU2V0cyB0aGUgY3VycmVudCBzdHlsZXMgZm9yIHRoZSBwb3BvdmVyIHRvIGFsbG93IGZvciBkeW5hbWljYWxseSBjaGFuZ2luZyBzZXR0aW5ncyAqL1xyXG4gIHNldEN1cnJlbnRTdHlsZXMoKSB7XHJcblxyXG4gICAgLy8gVE9ETzogU2VlIGlmIGFycm93IHBvc2l0aW9uIGNhbiBiZSBjYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYW5kIGFsbG93IG92ZXJyaWRlLlxyXG4gICAgLy8gVE9ETzogU2VlIGlmIGZsZXggb3JkZXIgaXMgYSBiZXR0ZXIgYWx0ZXJuYXRpdmUgdG8gcG9zaXRpb24gYXJyb3cgdG9wIG9yIGJvdHRvbS5cclxuICAgIHRoaXMucG9wb3ZlckFycm93U3R5bGVzID0ge1xyXG4gICAgICAncmlnaHQnOiB0aGlzLnBvc2l0aW9uWCA9PT0gJ2JlZm9yZScgPyAodGhpcy5hcnJvd09mZnNldFggLSB0aGlzLmFycm93V2lkdGgpICsgJ3B4JyA6ICcnLFxyXG4gICAgICAnbGVmdCc6IHRoaXMucG9zaXRpb25YID09PSAnYWZ0ZXInID8gKHRoaXMuYXJyb3dPZmZzZXRYIC0gdGhpcy5hcnJvd1dpZHRoKSArICdweCcgOiAnJyxcclxuICAgICAgJ2JvcmRlci10b3AnOiB0aGlzLnBvc2l0aW9uWSA9PT0gJ2JlbG93JyA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOiAnMHB4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1yaWdodCc6ICd1bmRlZmluZWQnID09PSB1bmRlZmluZWQgP1xyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCAnICsgdGhpcy5hcnJvd0NvbG9yIDpcclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgdHJhbnNwYXJlbnQnLFxyXG4gICAgICAnYm9yZGVyLWJvdHRvbSc6IHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnID9cclxuICAgICAgICB0aGlzLmFycm93V2lkdGggKyAncHggc29saWQgJyArIHRoaXMuYXJyb3dDb2xvciA6XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgJ2JvcmRlci1sZWZ0JzogJ3VuZGVmaW5lZCcgPT09IHVuZGVmaW5lZCA/XHJcbiAgICAgICAgdGhpcy5hcnJvd1dpZHRoICsgJ3B4IHNvbGlkICcgKyB0aGlzLmFycm93Q29sb3IgOlxyXG4gICAgICAgIHRoaXMuYXJyb3dXaWR0aCArICdweCBzb2xpZCB0cmFuc3BhcmVudCcsXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFRPRE86IFJlbW92ZSBpZiBmbGV4IG9yZGVyIGlzIGFkZGVkLlxyXG4gICAgdGhpcy5wb3BvdmVyQ29udGVudFN0eWxlcyA9IHtcclxuICAgICAgJ3BhZGRpbmctdG9wJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogdGhpcy5hcnJvd1dpZHRoICsgJ3B4JyxcclxuICAgICAgJ3BhZGRpbmctYm90dG9tJzogdGhpcy5vdmVybGFwVHJpZ2dlciA9PT0gdHJ1ZSA/ICcwcHgnIDogKHRoaXMuYXJyb3dXaWR0aCkgKyAncHgnLFxyXG4gICAgICAnbWFyZ2luLXRvcCc6IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlICYmIHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnICYmIHRoaXMuY29udGFpbmVyUG9zaXRpb25pbmcgPT09IGZhbHNlID9cclxuICAgICAgICAtKHRoaXMuYXJyb3dXaWR0aCAqIDIpICsgJ3B4JyA6ICcwcHgnXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSXQncyBuZWNlc3NhcnkgdG8gc2V0IHBvc2l0aW9uLWJhc2VkIGNsYXNzZXMgdG8gZW5zdXJlIHRoZSBwb3BvdmVyIHBhbmVsIGFuaW1hdGlvblxyXG4gICAqIGZvbGRzIG91dCBmcm9tIHRoZSBjb3JyZWN0IGRpcmVjdGlvbi5cclxuICAgKi9cclxuICBzZXRQb3NpdGlvbkNsYXNzZXMocG9zWCA9IHRoaXMucG9zaXRpb25YLCBwb3NZID0gdGhpcy5wb3NpdGlvblkpOiB2b2lkIHtcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYmVmb3JlJ10gPSBwb3NYID09PSAnYmVmb3JlJztcclxuICAgIHRoaXMuX2NsYXNzTGlzdFsnbWRlLXBvcG92ZXItYWZ0ZXInXSA9IHBvc1ggPT09ICdhZnRlcic7XHJcbiAgICB0aGlzLl9jbGFzc0xpc3RbJ21kZS1wb3BvdmVyLWFib3ZlJ10gPSBwb3NZID09PSAnYWJvdmUnO1xyXG4gICAgdGhpcy5fY2xhc3NMaXN0WydtZGUtcG9wb3Zlci1iZWxvdyddID0gcG9zWSA9PT0gJ2JlbG93JztcclxuICB9XHJcbn1cclxuIl19