/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, Input, Optional, Output, ViewContainerRef, HostListener, HostBinding, ChangeDetectorRef, } from '@angular/core';
import { isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { throwMdePopoverMissingError } from './popover-errors';
/**
 * This directive is intended to be used in conjunction with an mde-popover tag. It is
 * responsible for toggling the display of the provided popover instance.
 */
export class MdePopoverTrigger {
    /**
     * @param {?} _overlay
     * @param {?} _elementRef
     * @param {?} _viewContainerRef
     * @param {?} _dir
     * @param {?} _changeDetectorRef
     */
    constructor(_overlay, _elementRef, _viewContainerRef, _dir, _changeDetectorRef) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._dir = _dir;
        this._changeDetectorRef = _changeDetectorRef;
        // tslint:disable-line:directive-class-suffix
        this.ariaHaspopup = true;
        this._overlayRef = null;
        this._popoverOpen = false;
        this._halt = false;
        // tracking input type is necessary so it's possible to only auto-focus
        // the first item of the list when the popover is opened via the keyboard
        this._openedByMouse = false;
        /**
         * Popover backdrop close on click
         */
        this.backdropCloseOnClick = true;
        /**
         * Event emitted when the associated popover is opened.
         */
        this.opened = new EventEmitter();
        /**
         * Event emitted when the associated popover is closed.
         */
        this.closed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this._checkPopover();
        this._setCurrentConfig();
        this.popover.close.subscribe((/**
         * @return {?}
         */
        () => this.closePopover()));
    }
    /**
     * @return {?}
     */
    ngOnDestroy() { this.destroyPopover(); }
    /**
     * @private
     * @return {?}
     */
    _setCurrentConfig() {
        if (this.positionX === 'before' || this.positionX === 'after') {
            this.popover.positionX = this.positionX;
        }
        if (this.positionY === 'above' || this.positionY === 'below') {
            this.popover.positionY = this.positionY;
        }
        if (this.triggerEvent) {
            this.popover.triggerEvent = this.triggerEvent;
        }
        if (this.enterDelay) {
            this.popover.enterDelay = this.enterDelay;
        }
        if (this.leaveDelay) {
            this.popover.leaveDelay = this.leaveDelay;
        }
        if (this.overlapTrigger === true || this.overlapTrigger === false) {
            this.popover.overlapTrigger = this.overlapTrigger;
        }
        if (this.targetOffsetX) {
            this.popover.targetOffsetX = this.targetOffsetX;
        }
        if (this.targetOffsetY) {
            this.popover.targetOffsetY = this.targetOffsetY;
        }
        if (this.arrowOffsetX) {
            this.popover.arrowOffsetX = this.arrowOffsetX;
        }
        if (this.arrowWidth) {
            this.popover.arrowWidth = this.arrowWidth;
        }
        if (this.arrowColor) {
            this.popover.arrowColor = this.arrowColor;
        }
        if (this.closeOnClick === true || this.closeOnClick === false) {
            this.popover.closeOnClick = this.closeOnClick;
        }
        this.popover.setCurrentStyles();
    }
    /**
     * Whether the popover is open.
     * @return {?}
     */
    get popoverOpen() { return this._popoverOpen; }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.popover.triggerEvent === 'click') {
            // this.popover.setCurrentStyles();
            // this._setCurrentConfig();
            this.togglePopover();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseEnter(event) {
        this._halt = false;
        if (this.popover.triggerEvent === 'hover') {
            this._mouseoverTimer = setTimeout((/**
             * @return {?}
             */
            () => {
                this.openPopover();
            }), this.popover.enterDelay);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseLeave(event) {
        if (this.popover.triggerEvent === 'hover') {
            if (this._mouseoverTimer) {
                clearTimeout(this._mouseoverTimer);
                this._mouseoverTimer = null;
            }
            if (this._popoverOpen) {
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (!this.popover.closeDisabled) {
                        this.closePopover();
                    }
                }), this.popover.leaveDelay);
            }
            else {
                this._halt = true;
            }
        }
    }
    /**
     * Toggles the popover between the open and closed states.
     * @return {?}
     */
    togglePopover() {
        return this._popoverOpen ? this.closePopover() : this.openPopover();
    }
    /**
     * Opens the popover.
     * @return {?}
     */
    openPopover() {
        if (!this._popoverOpen && !this._halt) {
            this._createOverlay().attach(this._portal);
            /** Only subscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._subscribeToBackdrop();
            }
            this._initPopover();
        }
    }
    /**
     * Closes the popover.
     * @return {?}
     */
    closePopover() {
        if (this._overlayRef) {
            this._overlayRef.detach();
            /** Only unsubscribe to backdrop if trigger event is click */
            if (this.triggerEvent === 'click' && this.backdropCloseOnClick === true) {
                this._backdropSubscription.unsubscribe();
            }
            this._resetPopover();
        }
    }
    /**
     * Removes the popover from the DOM.
     * @return {?}
     */
    destroyPopover() {
        if (this._mouseoverTimer) {
            clearTimeout(this._mouseoverTimer);
            this._mouseoverTimer = null;
        }
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
            this._cleanUpSubscriptions();
        }
    }
    /**
     * Focuses the popover trigger.
     * @return {?}
     */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /**
     * The text direction of the containing app.
     * @return {?}
     */
    get dir() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * This method ensures that the popover closes when the overlay backdrop is clicked.
     * We do not use first() here because doing so would not catch clicks from within
     * the popover, and it would fail to unsubscribe properly. Instead, we unsubscribe
     * explicitly when the popover is closed or destroyed.
     * @private
     * @return {?}
     */
    _subscribeToBackdrop() {
        if (this._overlayRef) {
            this._backdropSubscription = this._overlayRef.backdropClick().subscribe((/**
             * @return {?}
             */
            () => {
                this.popover._emitCloseEvent();
            }));
        }
    }
    /**
     * This method sets the popover state to open and focuses the first item if
     * the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    _initPopover() {
        this._setIsPopoverOpen(true);
    }
    /**
     * This method resets the popover when it's closed, most importantly restoring
     * focus to the popover trigger if the popover was opened via the keyboard.
     * @private
     * @return {?}
     */
    _resetPopover() {
        this._setIsPopoverOpen(false);
        // Focus only needs to be reset to the host element if the popover was opened
        // by the keyboard and manually shifted to the first popover item.
        if (!this._openedByMouse) {
            this.focus();
        }
        this._openedByMouse = false;
    }
    /**
     * set state rather than toggle to support triggers sharing a popover
     * @private
     * @param {?} isOpen
     * @return {?}
     */
    _setIsPopoverOpen(isOpen) {
        this._popoverOpen = isOpen;
        this._popoverOpen ? this.opened.emit() : this.closed.emit();
    }
    /**
     *  This method checks that a valid instance of MdPopover has been passed into
     *  mdPopoverTriggerFor. If not, an exception is thrown.
     * @private
     * @return {?}
     */
    _checkPopover() {
        if (!this.popover) {
            throwMdePopoverMissingError();
        }
    }
    /**
     *  This method creates the overlay from the provided popover's template and saves its
     *  OverlayRef so that it can be attached to the DOM when openPopover is called.
     * @private
     * @return {?}
     */
    _createOverlay() {
        if (!this._overlayRef) {
            this._portal = new TemplatePortal(this.popover.templateRef, this._viewContainerRef);
            /** @type {?} */
            const config = this._getOverlayConfig();
            this._subscribeToPositions((/** @type {?} */ (config.positionStrategy)));
            this._overlayRef = this._overlay.create(config);
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayConfig.
     * @private
     * @return {?} OverlayConfig
     */
    _getOverlayConfig() {
        /** @type {?} */
        const overlayState = new OverlayConfig();
        overlayState.positionStrategy = this._getPosition();
        /** Display overlay backdrop if trigger event is click */
        if (this.triggerEvent === 'click') {
            overlayState.hasBackdrop = true;
            overlayState.backdropClass = 'cdk-overlay-transparent-backdrop';
        }
        overlayState.direction = this.dir;
        overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        return overlayState;
    }
    /**
     * Listens to changes in the position of the overlay and sets the correct classes
     * on the popover based on the new position. This ensures the animation origin is always
     * correct, even if a fallback position is used for the overlay.
     * @private
     * @param {?} position
     * @return {?}
     */
    _subscribeToPositions(position) {
        this._positionSubscription = position.positionChanges.subscribe((/**
         * @param {?} change
         * @return {?}
         */
        change => {
            /** @type {?} */
            const posisionX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';
            /** @type {?} */
            let posisionY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';
            if (!this.popover.overlapTrigger) {
                posisionY = posisionY === 'below' ? 'above' : 'below';
            }
            // required for ChangeDetectionStrategy.OnPush
            this._changeDetectorRef.markForCheck();
            this.popover.zone.run((/**
             * @return {?}
             */
            () => {
                this.popover.positionX = posisionX;
                this.popover.positionY = posisionY;
                this.popover.setCurrentStyles();
                this.popover.setPositionClasses(posisionX, posisionY);
            }));
        }));
    }
    /**
     * This method builds the position strategy for the overlay, so the popover is properly connected
     * to the trigger.
     * @private
     * @return {?} ConnectedPositionStrategy
     */
    _getPosition() {
        const [originX, originFallbackX] = this.popover.positionX === 'before' ? ['end', 'start'] : ['start', 'end'];
        const [overlayY, overlayFallbackY] = this.popover.positionY === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];
        // let originY = overlayY;
        // let fallbackOriginY = overlayFallbackY;
        /** @type {?} */
        let originY = overlayY;
        /** @type {?} */
        let originFallbackY = overlayFallbackY;
        /** @type {?} */
        const overlayX = originX;
        /** @type {?} */
        const overlayFallbackX = originFallbackX;
        // let [originY, originFallbackY] = [overlayY, overlayFallbackY];
        // let [overlayX, overlayFallbackX] = [originX, originFallbackX];
        /** Reverse overlayY and fallbackOverlayY when overlapTrigger is false */
        if (!this.popover.overlapTrigger) {
            originY = overlayY === 'top' ? 'bottom' : 'top';
            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';
        }
        /** @type {?} */
        let offsetX = 0;
        /** @type {?} */
        let offsetY = 0;
        if (this.popover.targetOffsetX && !isNaN(Number(this.popover.targetOffsetX))) {
            offsetX = Number(this.popover.targetOffsetX);
            // offsetX = -16;
        }
        if (this.popover.targetOffsetY && !isNaN(Number(this.popover.targetOffsetY))) {
            offsetY = Number(this.popover.targetOffsetY);
            // offsetY = -10;
        }
        /**
         * For overriding position element, when mdePopoverTargetAt has a valid element reference.
         * Useful for sticking popover to parent element and offsetting arrow to trigger element.
         * If undefined defaults to the trigger element reference.
         * @type {?}
         */
        let element = this._elementRef;
        if (typeof this.targetElement !== 'undefined') {
            this.popover.containerPositioning = true;
            element = this.targetElement._elementRef;
        }
        return this._overlay.position()
            .flexibleConnectedTo(element)
            .withPositions([
            {
                originX,
                originY,
                overlayX,
                overlayY,
                offsetY
            },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetY
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetY: -offsetY
            }
        ])
            .withDefaultOffsetX(offsetX)
            .withDefaultOffsetY(offsetY);
        /*
        return this._overlay.position()
          .connectedTo(element,
              {originX: posX, originY: originY},
              {overlayX: posX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: originY},
              {overlayX: fallbackX, overlayY: overlayY})
          .withFallbackPosition(
              {originX: posX, originY: fallbackOriginY},
              {overlayX: posX, overlayY: fallbackOverlayY})
          .withFallbackPosition(
              {originX: fallbackX, originY: fallbackOriginY},
              {overlayX: fallbackX, overlayY: fallbackOverlayY})
          .withOffsetX(offsetX)
          .withOffsetY(offsetY);
          */
    }
    /**
     * @private
     * @return {?}
     */
    _cleanUpSubscriptions() {
        if (this._backdropSubscription) {
            this._backdropSubscription.unsubscribe();
        }
        if (this._positionSubscription) {
            this._positionSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    _handleMousedown(event) {
        if (event && !isFakeMousedownFromScreenReader(event)) {
            this._openedByMouse = true;
        }
    }
}
MdePopoverTrigger.decorators = [
    { type: Directive, args: [{
                selector: '[mdePopoverTriggerFor]',
                exportAs: 'mdePopoverTrigger'
            },] }
];
/** @nocollapse */
MdePopoverTrigger.ctorParameters = () => [
    { type: Overlay },
    { type: ElementRef },
    { type: ViewContainerRef },
    { type: Directionality, decorators: [{ type: Optional }] },
    { type: ChangeDetectorRef }
];
MdePopoverTrigger.propDecorators = {
    ariaHaspopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
    popover: [{ type: Input, args: ['mdePopoverTriggerFor',] }],
    targetElement: [{ type: Input, args: ['mdePopoverTargetAt',] }],
    positionX: [{ type: Input, args: ['mdePopoverPositionX',] }],
    positionY: [{ type: Input, args: ['mdePopoverPositionY',] }],
    triggerEvent: [{ type: Input, args: ['mdePopoverTriggerOn',] }],
    enterDelay: [{ type: Input, args: ['mdePopoverEnterDelay',] }],
    leaveDelay: [{ type: Input, args: ['mdePopoverLeaveDelay',] }],
    overlapTrigger: [{ type: Input, args: ['mdePopoverOverlapTrigger',] }],
    targetOffsetX: [{ type: Input, args: ['mdePopoverOffsetX',] }],
    targetOffsetY: [{ type: Input, args: ['mdePopoverOffsetY',] }],
    arrowOffsetX: [{ type: Input, args: ['mdePopoverArrowOffsetX',] }],
    arrowWidth: [{ type: Input, args: ['mdePopoverArrowWidth',] }],
    arrowColor: [{ type: Input, args: ['mdePopoverArrowColor',] }],
    closeOnClick: [{ type: Input, args: ['mdePopoverCloseOnClick',] }],
    backdropCloseOnClick: [{ type: Input, args: ['mdePopoverBackdropCloseOnClick',] }],
    opened: [{ type: Output }],
    closed: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
    onMouseEnter: [{ type: HostListener, args: ['mouseenter', ['$event'],] }],
    onMouseLeave: [{ type: HostListener, args: ['mouseleave', ['$event'],] }],
    _handleMousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    MdePopoverTrigger.prototype.ariaHaspopup;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._portal;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._overlayRef;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._popoverOpen;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._halt;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._backdropSubscription;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._positionSubscription;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._mouseoverTimer;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._openedByMouse;
    /**
     * References the popover instance that the trigger is associated with.
     * @type {?}
     */
    MdePopoverTrigger.prototype.popover;
    /**
     * References the popover target instance that the trigger is associated with.
     * @type {?}
     */
    MdePopoverTrigger.prototype.targetElement;
    /**
     * Position of the popover in the X axis
     * @type {?}
     */
    MdePopoverTrigger.prototype.positionX;
    /**
     * Position of the popover in the Y axis
     * @type {?}
     */
    MdePopoverTrigger.prototype.positionY;
    /**
     * Popover trigger event
     * @type {?}
     */
    MdePopoverTrigger.prototype.triggerEvent;
    /**
     * Popover delay
     * @type {?}
     */
    MdePopoverTrigger.prototype.enterDelay;
    /**
     * Popover delay
     * @type {?}
     */
    MdePopoverTrigger.prototype.leaveDelay;
    /**
     * Popover overlap trigger
     * @type {?}
     */
    MdePopoverTrigger.prototype.overlapTrigger;
    /**
     * Popover target offset x
     * @type {?}
     */
    MdePopoverTrigger.prototype.targetOffsetX;
    /**
     * Popover target offset y
     * @type {?}
     */
    MdePopoverTrigger.prototype.targetOffsetY;
    /**
     * Popover arrow offset x
     * @type {?}
     */
    MdePopoverTrigger.prototype.arrowOffsetX;
    /**
     * Popover arrow width
     * @type {?}
     */
    MdePopoverTrigger.prototype.arrowWidth;
    /**
     * Popover arrow color
     * @type {?}
     */
    MdePopoverTrigger.prototype.arrowColor;
    /**
     * Popover container close on click
     * @type {?}
     */
    MdePopoverTrigger.prototype.closeOnClick;
    /**
     * Popover backdrop close on click
     * @type {?}
     */
    MdePopoverTrigger.prototype.backdropCloseOnClick;
    /**
     * Event emitted when the associated popover is opened.
     * @type {?}
     */
    MdePopoverTrigger.prototype.opened;
    /**
     * Event emitted when the associated popover is closed.
     * @type {?}
     */
    MdePopoverTrigger.prototype.closed;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._overlay;
    /** @type {?} */
    MdePopoverTrigger.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._viewContainerRef;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._dir;
    /**
     * @type {?}
     * @private
     */
    MdePopoverTrigger.prototype._changeDetectorRef;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG1hdGVyaWFsLWV4dGVuZGVkL21kZS8iLCJzb3VyY2VzIjpbImxpYi9wb3BvdmVyL3BvcG92ZXItdHJpZ2dlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUVMLFNBQVMsRUFDVCxVQUFVLEVBQ1YsWUFBWSxFQUNaLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLGdCQUFnQixFQUNoQixZQUFZLEVBQ1osV0FBVyxFQUNYLGlCQUFpQixHQUNsQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRSxPQUFPLEVBQWEsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDOUQsT0FBTyxFQUNMLE9BQU8sRUFFUCxhQUFhLEVBSWQsTUFBTSxzQkFBc0IsQ0FBQztBQUM5QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFNckQsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7O0FBYS9ELE1BQU0sT0FBTyxpQkFBaUI7Ozs7Ozs7O0lBeUUxQixZQUFvQixRQUFpQixFQUFTLFdBQXVCLEVBQ25ELGlCQUFtQyxFQUN2QixJQUFvQixFQUNoQyxrQkFBcUM7UUFIbkMsYUFBUSxHQUFSLFFBQVEsQ0FBUztRQUFTLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ25ELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBa0I7UUFDdkIsU0FBSSxHQUFKLElBQUksQ0FBZ0I7UUFDaEMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjs7UUExRXBCLGlCQUFZLEdBQUcsSUFBSSxDQUFDO1FBRy9DLGdCQUFXLEdBQXNCLElBQUksQ0FBQztRQUN0QyxpQkFBWSxHQUFHLEtBQUssQ0FBQztRQUNyQixVQUFLLEdBQUcsS0FBSyxDQUFDOzs7UUFRZCxtQkFBYyxHQUFHLEtBQUss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QUFFLENBQUMsUUFBUSxDQUFDOzs7O0lBL2NyQyx5Q0FBdUQ7Ozs7O0lBRXZELG9DQUFxQzs7Ozs7SUFDckMsd0NBQThDOzs7OztJQUM5Qyx5Q0FBNkI7Ozs7O0lBQzdCLGtDQUFzQjs7Ozs7SUFDdEIsa0RBQTRDOzs7OztJQUM1QyxrREFBNEM7Ozs7O0lBRTVDLDRDQUE2Qjs7Ozs7SUFJN0IsMkNBQStCOzs7OztJQUcvQixvQ0FBd0Q7Ozs7O0lBR3hELDBDQUFzRDs7Ozs7SUFHdEQsc0NBQTZEOzs7OztJQUc3RCxzQ0FBNkQ7Ozs7O0lBRzdELHlDQUFtRTs7Ozs7SUFHbkUsdUNBQWtEOzs7OztJQUdsRCx1Q0FBa0Q7Ozs7O0lBR2xELDJDQUEyRDs7Ozs7SUFHM0QsMENBQWtEOzs7OztJQUdsRCwwQ0FBa0Q7Ozs7O0lBR2xELHlDQUFzRDs7Ozs7SUFJdEQsdUNBQWtEOzs7OztJQUlsRCx1Q0FBa0Q7Ozs7O0lBSWxELHlDQUF1RDs7Ozs7SUFJdkQsaURBQXFFOzs7OztJQUdyRSxtQ0FBNEM7Ozs7O0lBRzVDLG1DQUE0Qzs7Ozs7SUFHaEMscUNBQXlCOztJQUFFLHdDQUE4Qjs7Ozs7SUFDM0QsOENBQTJDOzs7OztJQUMzQyxpQ0FBd0M7Ozs7O0lBQ3hDLCtDQUE2QyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQWZ0ZXJWaWV3SW5pdCxcclxuICBEaXJlY3RpdmUsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgT25EZXN0cm95LFxyXG4gIE9wdGlvbmFsLFxyXG4gIE91dHB1dCxcclxuICBWaWV3Q29udGFpbmVyUmVmLFxyXG4gIEhvc3RMaXN0ZW5lcixcclxuICBIb3N0QmluZGluZyxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7IGlzRmFrZU1vdXNlZG93bkZyb21TY3JlZW5SZWFkZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XHJcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XHJcbmltcG9ydCB7XHJcbiAgT3ZlcmxheSxcclxuICBPdmVybGF5UmVmLFxyXG4gIE92ZXJsYXlDb25maWcsXHJcbiAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXHJcbiAgVmVydGljYWxDb25uZWN0aW9uUG9zLFxyXG4gIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneVxyXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcclxuaW1wb3J0IHsgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcclxuXHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5cclxuaW1wb3J0IHsgTWRlUG9wb3ZlclBhbmVsLCBNZGVUYXJnZXQgfSBmcm9tICcuL3BvcG92ZXItaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IE1kZVBvcG92ZXJQb3NpdGlvblgsIE1kZVBvcG92ZXJQb3NpdGlvblksIE1kZVBvcG92ZXJUcmlnZ2VyRXZlbnQgfSBmcm9tICcuL3BvcG92ZXItdHlwZXMnO1xyXG5pbXBvcnQgeyB0aHJvd01kZVBvcG92ZXJNaXNzaW5nRXJyb3IgfSBmcm9tICcuL3BvcG92ZXItZXJyb3JzJztcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBhbiBtZGUtcG9wb3ZlciB0YWcuIEl0IGlzXHJcbiAqIHJlc3BvbnNpYmxlIGZvciB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiB0aGUgcHJvdmlkZWQgcG9wb3ZlciBpbnN0YW5jZS5cclxuICovXHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1ttZGVQb3BvdmVyVHJpZ2dlckZvcl0nLFxyXG4gIGV4cG9ydEFzOiAnbWRlUG9wb3ZlclRyaWdnZXInXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBNZGVQb3BvdmVyVHJpZ2dlciBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7IC8vIHRzbGludDpkaXNhYmxlLWxpbmU6ZGlyZWN0aXZlLWNsYXNzLXN1ZmZpeFxyXG5cclxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWhhc3BvcHVwJykgYXJpYUhhc3BvcHVwID0gdHJ1ZTtcclxuXHJcbiAgICBwcml2YXRlIF9wb3J0YWw6IFRlbXBsYXRlUG9ydGFsPGFueT47XHJcbiAgICBwcml2YXRlIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmIHwgbnVsbCA9IG51bGw7XHJcbiAgICBwcml2YXRlIF9wb3BvdmVyT3BlbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfaGFsdCA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfYmFja2Ryb3BTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcclxuICAgIHByaXZhdGUgX3Bvc2l0aW9uU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XHJcblxyXG4gICAgcHJpdmF0ZSBfbW91c2VvdmVyVGltZXI6IGFueTtcclxuXHJcbiAgICAvLyB0cmFja2luZyBpbnB1dCB0eXBlIGlzIG5lY2Vzc2FyeSBzbyBpdCdzIHBvc3NpYmxlIHRvIG9ubHkgYXV0by1mb2N1c1xyXG4gICAgLy8gdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIGxpc3Qgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQgdmlhIHRoZSBrZXlib2FyZFxyXG4gICAgcHJpdmF0ZSBfb3BlbmVkQnlNb3VzZSA9IGZhbHNlO1xyXG5cclxuICAgIC8qKiBSZWZlcmVuY2VzIHRoZSBwb3BvdmVyIGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyVHJpZ2dlckZvcicpIHBvcG92ZXI6IE1kZVBvcG92ZXJQYW5lbDtcclxuXHJcbiAgICAvKiogUmVmZXJlbmNlcyB0aGUgcG9wb3ZlciB0YXJnZXQgaW5zdGFuY2UgdGhhdCB0aGUgdHJpZ2dlciBpcyBhc3NvY2lhdGVkIHdpdGguICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJUYXJnZXRBdCcpIHRhcmdldEVsZW1lbnQ6IE1kZVRhcmdldDtcclxuXHJcbiAgICAvKiogUG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgaW4gdGhlIFggYXhpcyAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyUG9zaXRpb25YJykgcG9zaXRpb25YOiBNZGVQb3BvdmVyUG9zaXRpb25YO1xyXG5cclxuICAgIC8qKiBQb3NpdGlvbiBvZiB0aGUgcG9wb3ZlciBpbiB0aGUgWSBheGlzICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJQb3NpdGlvblknKSBwb3NpdGlvblk6IE1kZVBvcG92ZXJQb3NpdGlvblk7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgdHJpZ2dlciBldmVudCAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyVHJpZ2dlck9uJykgdHJpZ2dlckV2ZW50OiBNZGVQb3BvdmVyVHJpZ2dlckV2ZW50O1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIGRlbGF5ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJFbnRlckRlbGF5JykgZW50ZXJEZWxheTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIGRlbGF5ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJMZWF2ZURlbGF5JykgbGVhdmVEZWxheTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIG92ZXJsYXAgdHJpZ2dlciAqL1xyXG4gICAgQElucHV0KCdtZGVQb3BvdmVyT3ZlcmxhcFRyaWdnZXInKSBvdmVybGFwVHJpZ2dlcjogYm9vbGVhbjtcclxuXHJcbiAgICAvKiogUG9wb3ZlciB0YXJnZXQgb2Zmc2V0IHggKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3Zlck9mZnNldFgnKSB0YXJnZXRPZmZzZXRYOiBudW1iZXI7XHJcblxyXG4gICAgLyoqIFBvcG92ZXIgdGFyZ2V0IG9mZnNldCB5ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJPZmZzZXRZJykgdGFyZ2V0T2Zmc2V0WTogbnVtYmVyO1xyXG5cclxuICAgIC8qKiBQb3BvdmVyIGFycm93IG9mZnNldCB4ICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd09mZnNldFgnKSBhcnJvd09mZnNldFg6IG51bWJlcjtcclxuXHJcblxyXG4gICAgLyoqIFBvcG92ZXIgYXJyb3cgd2lkdGggKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckFycm93V2lkdGgnKSBhcnJvd1dpZHRoOiBudW1iZXI7XHJcblxyXG5cclxuICAgIC8qKiBQb3BvdmVyIGFycm93IGNvbG9yICovXHJcbiAgICBASW5wdXQoJ21kZVBvcG92ZXJBcnJvd0NvbG9yJykgYXJyb3dDb2xvcjogc3RyaW5nO1xyXG5cclxuXHJcbiAgICAvKiogUG9wb3ZlciBjb250YWluZXIgY2xvc2Ugb24gY2xpY2sgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckNsb3NlT25DbGljaycpIGNsb3NlT25DbGljazogYm9vbGVhbjtcclxuXHJcblxyXG4gICAgLyoqIFBvcG92ZXIgYmFja2Ryb3AgY2xvc2Ugb24gY2xpY2sgKi9cclxuICAgIEBJbnB1dCgnbWRlUG9wb3ZlckJhY2tkcm9wQ2xvc2VPbkNsaWNrJykgYmFja2Ryb3BDbG9zZU9uQ2xpY2sgPSB0cnVlO1xyXG5cclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBvcGVuZWQuICovXHJcbiAgICBAT3V0cHV0KCkgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgcG9wb3ZlciBpcyBjbG9zZWQuICovXHJcbiAgICBAT3V0cHV0KCkgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xyXG5cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5LFxyXG4gICAgICAgICAgICAgIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikgeyB9XHJcblxyXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrUG9wb3ZlcigpO1xyXG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRDb25maWcoKTtcclxuICAgICAgICB0aGlzLnBvcG92ZXIuY2xvc2Uuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2xvc2VQb3BvdmVyKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCkgeyB0aGlzLmRlc3Ryb3lQb3BvdmVyKCk7IH1cclxuXHJcblxyXG4gICAgcHJpdmF0ZSBfc2V0Q3VycmVudENvbmZpZygpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25YID09PSAnYmVmb3JlJyB8fCB0aGlzLnBvc2l0aW9uWCA9PT0gJ2FmdGVyJykge1xyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLnBvc2l0aW9uWCA9IHRoaXMucG9zaXRpb25YO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25ZID09PSAnYWJvdmUnIHx8IHRoaXMucG9zaXRpb25ZID09PSAnYmVsb3cnKSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID0gdGhpcy5wb3NpdGlvblk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9IHRoaXMudHJpZ2dlckV2ZW50O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZW50ZXJEZWxheSkge1xyXG4gICAgICAgICAgdGhpcy5wb3BvdmVyLmVudGVyRGVsYXkgPSB0aGlzLmVudGVyRGVsYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5sZWF2ZURlbGF5KSB7XHJcbiAgICAgICAgICB0aGlzLnBvcG92ZXIubGVhdmVEZWxheSA9IHRoaXMubGVhdmVEZWxheTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXBUcmlnZ2VyID09PSB0cnVlIHx8IHRoaXMub3ZlcmxhcFRyaWdnZXIgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5vdmVybGFwVHJpZ2dlciA9IHRoaXMub3ZlcmxhcFRyaWdnZXI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50YXJnZXRPZmZzZXRYKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYID0gdGhpcy50YXJnZXRPZmZzZXRYO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudGFyZ2V0T2Zmc2V0WSkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSA9IHRoaXMudGFyZ2V0T2Zmc2V0WTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmFycm93T2Zmc2V0WCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dPZmZzZXRYID0gdGhpcy5hcnJvd09mZnNldFg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hcnJvd1dpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5hcnJvd1dpZHRoID0gdGhpcy5hcnJvd1dpZHRoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuYXJyb3dDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dDb2xvciA9IHRoaXMuYXJyb3dDb2xvcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmNsb3NlT25DbGljayA9PT0gdHJ1ZSB8fCB0aGlzLmNsb3NlT25DbGljayA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmNsb3NlT25DbGljayA9IHRoaXMuY2xvc2VPbkNsaWNrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgaXMgb3Blbi4gKi9cclxuICAgIGdldCBwb3BvdmVyT3BlbigpOiBib29sZWFuIHsgcmV0dXJuIHRoaXMuX3BvcG92ZXJPcGVuOyB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgIGlmICh0aGlzLnBvcG92ZXIudHJpZ2dlckV2ZW50ID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICAvLyB0aGlzLnBvcG92ZXIuc2V0Q3VycmVudFN0eWxlcygpO1xyXG4gICAgICAgICAgLy8gdGhpcy5fc2V0Q3VycmVudENvbmZpZygpO1xyXG4gICAgICAgICAgdGhpcy50b2dnbGVQb3BvdmVyKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJywgWyckZXZlbnQnXSkgb25Nb3VzZUVudGVyKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgIHRoaXMuX2hhbHQgPSBmYWxzZTtcclxuICAgICAgaWYgKHRoaXMucG9wb3Zlci50cmlnZ2VyRXZlbnQgPT09ICdob3ZlcicpIHtcclxuICAgICAgICAgIHRoaXMuX21vdXNlb3ZlclRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgdGhpcy5vcGVuUG9wb3ZlcigpO1xyXG4gICAgICAgICAgfSwgdGhpcy5wb3BvdmVyLmVudGVyRGVsYXkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScsIFsnJGV2ZW50J10pIG9uTW91c2VMZWF2ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICBpZiAodGhpcy5wb3BvdmVyLnRyaWdnZXJFdmVudCA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgIGlmICh0aGlzLl9tb3VzZW92ZXJUaW1lcikge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fbW91c2VvdmVyVGltZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3VzZW92ZXJUaW1lciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wb3BvdmVyT3Blbikge1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wb3BvdmVyLmNsb3NlRGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlUG9wb3ZlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCB0aGlzLnBvcG92ZXIubGVhdmVEZWxheSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuX2hhbHQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBUb2dnbGVzIHRoZSBwb3BvdmVyIGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXHJcbiAgICB0b2dnbGVQb3BvdmVyKCk6IHZvaWQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb3BvdmVyT3BlbiA/IHRoaXMuY2xvc2VQb3BvdmVyKCkgOiB0aGlzLm9wZW5Qb3BvdmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIE9wZW5zIHRoZSBwb3BvdmVyLiAqL1xyXG4gICAgb3BlblBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wb3BvdmVyT3BlbiAmJiAhdGhpcy5faGFsdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPdmVybGF5KCkuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XHJcblxyXG4gICAgICAgICAgICAvKiogT25seSBzdWJzY3JpYmUgdG8gYmFja2Ryb3AgaWYgdHJpZ2dlciBldmVudCBpcyBjbGljayAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycgJiYgdGhpcy5iYWNrZHJvcENsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvQmFja2Ryb3AoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5faW5pdFBvcG92ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqIENsb3NlcyB0aGUgcG9wb3Zlci4gKi9cclxuICAgIGNsb3NlUG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcclxuXHJcbiAgICAgICAgICAvKiogT25seSB1bnN1YnNjcmliZSB0byBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgICBpZiAodGhpcy50cmlnZ2VyRXZlbnQgPT09ICdjbGljaycgJiYgdGhpcy5iYWNrZHJvcENsb3NlT25DbGljayA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9iYWNrZHJvcFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRoaXMuX3Jlc2V0UG9wb3ZlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKiogUmVtb3ZlcyB0aGUgcG9wb3ZlciBmcm9tIHRoZSBET00uICovXHJcbiAgICBkZXN0cm95UG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fbW91c2VvdmVyVGltZXIpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX21vdXNlb3ZlclRpbWVyKTtcclxuICAgICAgICAgICAgdGhpcy5fbW91c2VvdmVyVGltZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kaXNwb3NlKCk7XHJcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX2NsZWFuVXBTdWJzY3JpcHRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKiBGb2N1c2VzIHRoZSBwb3BvdmVyIHRyaWdnZXIuICovXHJcbiAgICBmb2N1cygpIHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKiogVGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cclxuICAgIGdldCBkaXIoKTogRGlyZWN0aW9uIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlyICYmIHRoaXMuX2Rpci52YWx1ZSA9PT0gJ3J0bCcgPyAncnRsJyA6ICdsdHInO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoYXQgdGhlIHBvcG92ZXIgY2xvc2VzIHdoZW4gdGhlIG92ZXJsYXkgYmFja2Ryb3AgaXMgY2xpY2tlZC5cclxuICAgICogV2UgZG8gbm90IHVzZSBmaXJzdCgpIGhlcmUgYmVjYXVzZSBkb2luZyBzbyB3b3VsZCBub3QgY2F0Y2ggY2xpY2tzIGZyb20gd2l0aGluXHJcbiAgICAqIHRoZSBwb3BvdmVyLCBhbmQgaXQgd291bGQgZmFpbCB0byB1bnN1YnNjcmliZSBwcm9wZXJseS4gSW5zdGVhZCwgd2UgdW5zdWJzY3JpYmVcclxuICAgICogZXhwbGljaXRseSB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZCBvciBkZXN0cm95ZWQuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9CYWNrZHJvcCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xyXG4gICAgICAgICAgdGhpcy5fYmFja2Ryb3BTdWJzY3JpcHRpb24gPSB0aGlzLl9vdmVybGF5UmVmLmJhY2tkcm9wQ2xpY2soKS5zdWJzY3JpYmUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuX2VtaXRDbG9zZUV2ZW50KCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIHNldHMgdGhlIHBvcG92ZXIgc3RhdGUgdG8gb3BlbiBhbmQgZm9jdXNlcyB0aGUgZmlyc3QgaXRlbSBpZlxyXG4gICAgKiB0aGUgcG9wb3ZlciB3YXMgb3BlbmVkIHZpYSB0aGUga2V5Ym9hcmQuXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfaW5pdFBvcG92ZXIoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc2V0SXNQb3BvdmVyT3Blbih0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2QgcmVzZXRzIHRoZSBwb3BvdmVyIHdoZW4gaXQncyBjbG9zZWQsIG1vc3QgaW1wb3J0YW50bHkgcmVzdG9yaW5nXHJcbiAgICAqIGZvY3VzIHRvIHRoZSBwb3BvdmVyIHRyaWdnZXIgaWYgdGhlIHBvcG92ZXIgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX3Jlc2V0UG9wb3ZlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9zZXRJc1BvcG92ZXJPcGVuKGZhbHNlKTtcclxuXHJcbiAgICAgICAgLy8gRm9jdXMgb25seSBuZWVkcyB0byBiZSByZXNldCB0byB0aGUgaG9zdCBlbGVtZW50IGlmIHRoZSBwb3BvdmVyIHdhcyBvcGVuZWRcclxuICAgICAgICAvLyBieSB0aGUga2V5Ym9hcmQgYW5kIG1hbnVhbGx5IHNoaWZ0ZWQgdG8gdGhlIGZpcnN0IHBvcG92ZXIgaXRlbS5cclxuICAgICAgICBpZiAoIXRoaXMuX29wZW5lZEJ5TW91c2UpIHtcclxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb3BlbmVkQnlNb3VzZSA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKiBzZXQgc3RhdGUgcmF0aGVyIHRoYW4gdG9nZ2xlIHRvIHN1cHBvcnQgdHJpZ2dlcnMgc2hhcmluZyBhIHBvcG92ZXIgKi9cclxuICAgIHByaXZhdGUgX3NldElzUG9wb3Zlck9wZW4oaXNPcGVuOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fcG9wb3Zlck9wZW4gPSBpc09wZW47XHJcbiAgICAgICAgdGhpcy5fcG9wb3Zlck9wZW4gPyB0aGlzLm9wZW5lZC5lbWl0KCkgOiB0aGlzLmNsb3NlZC5lbWl0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqICBUaGlzIG1ldGhvZCBjaGVja3MgdGhhdCBhIHZhbGlkIGluc3RhbmNlIG9mIE1kUG9wb3ZlciBoYXMgYmVlbiBwYXNzZWQgaW50b1xyXG4gICAgKiAgbWRQb3BvdmVyVHJpZ2dlckZvci4gSWYgbm90LCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2NoZWNrUG9wb3ZlcigpIHtcclxuICAgICAgICBpZiAoIXRoaXMucG9wb3Zlcikge1xyXG4gICAgICAgICAgdGhyb3dNZGVQb3BvdmVyTWlzc2luZ0Vycm9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiAgVGhpcyBtZXRob2QgY3JlYXRlcyB0aGUgb3ZlcmxheSBmcm9tIHRoZSBwcm92aWRlZCBwb3BvdmVyJ3MgdGVtcGxhdGUgYW5kIHNhdmVzIGl0c1xyXG4gICAgKiAgT3ZlcmxheVJlZiBzbyB0aGF0IGl0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIHdoZW4gb3BlblBvcG92ZXIgaXMgY2FsbGVkLlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmKSB7XHJcbiAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5wb3BvdmVyLnRlbXBsYXRlUmVmLCB0aGlzLl92aWV3Q29udGFpbmVyUmVmKTtcclxuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuX2dldE92ZXJsYXlDb25maWcoKTtcclxuICAgICAgICAgIHRoaXMuX3N1YnNjcmliZVRvUG9zaXRpb25zKGNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk7XHJcbiAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBUaGlzIG1ldGhvZCBidWlsZHMgdGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0IG5lZWRlZCB0byBjcmVhdGUgdGhlIG92ZXJsYXksIHRoZSBPdmVybGF5Q29uZmlnLlxyXG4gICAgKiBAcmV0dXJucyBPdmVybGF5Q29uZmlnXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZygpOiBPdmVybGF5Q29uZmlnIHtcclxuICAgICAgICBjb25zdCBvdmVybGF5U3RhdGUgPSBuZXcgT3ZlcmxheUNvbmZpZygpO1xyXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5fZ2V0UG9zaXRpb24oKTtcclxuXHJcbiAgICAgICAgLyoqIERpc3BsYXkgb3ZlcmxheSBiYWNrZHJvcCBpZiB0cmlnZ2VyIGV2ZW50IGlzIGNsaWNrICovXHJcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlckV2ZW50ID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xyXG4gICAgICAgICAgb3ZlcmxheVN0YXRlLmJhY2tkcm9wQ2xhc3MgPSAnY2RrLW92ZXJsYXktdHJhbnNwYXJlbnQtYmFja2Ryb3AnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgb3ZlcmxheVN0YXRlLmRpcmVjdGlvbiA9IHRoaXMuZGlyO1xyXG4gICAgICAgIG92ZXJsYXlTdGF0ZS5zY3JvbGxTdHJhdGVneSA9IHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIG92ZXJsYXlTdGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogTGlzdGVucyB0byBjaGFuZ2VzIGluIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3ZlcmxheSBhbmQgc2V0cyB0aGUgY29ycmVjdCBjbGFzc2VzXHJcbiAgICAqIG9uIHRoZSBwb3BvdmVyIGJhc2VkIG9uIHRoZSBuZXcgcG9zaXRpb24uIFRoaXMgZW5zdXJlcyB0aGUgYW5pbWF0aW9uIG9yaWdpbiBpcyBhbHdheXNcclxuICAgICogY29ycmVjdCwgZXZlbiBpZiBhIGZhbGxiYWNrIHBvc2l0aW9uIGlzIHVzZWQgZm9yIHRoZSBvdmVybGF5LlxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvUG9zaXRpb25zKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbiA9IHBvc2l0aW9uLnBvc2l0aW9uQ2hhbmdlcy5zdWJzY3JpYmUoY2hhbmdlID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zaXNpb25YOiBNZGVQb3BvdmVyUG9zaXRpb25YID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlYID09PSAnc3RhcnQnID8gJ2FmdGVyJyA6ICdiZWZvcmUnO1xyXG4gICAgICAgICAgICBsZXQgcG9zaXNpb25ZOiBNZGVQb3BvdmVyUG9zaXRpb25ZID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyLm92ZXJsYXlZID09PSAndG9wJyA/ICdiZWxvdycgOiAnYWJvdmUnO1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIub3ZlcmxhcFRyaWdnZXIpIHtcclxuICAgICAgICAgICAgICAgIHBvc2lzaW9uWSA9IHBvc2lzaW9uWSA9PT0gJ2JlbG93JyA/ICdhYm92ZScgOiAnYmVsb3cnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyByZXF1aXJlZCBmb3IgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXHJcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnpvbmUucnVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblggPSBwb3Npc2lvblg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcG92ZXIucG9zaXRpb25ZID0gcG9zaXNpb25ZO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3BvdmVyLnNldEN1cnJlbnRTdHlsZXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcG92ZXIuc2V0UG9zaXRpb25DbGFzc2VzKHBvc2lzaW9uWCwgcG9zaXNpb25ZKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgZm9yIHRoZSBvdmVybGF5LCBzbyB0aGUgcG9wb3ZlciBpcyBwcm9wZXJseSBjb25uZWN0ZWRcclxuICAgICogdG8gdGhlIHRyaWdnZXIuXHJcbiAgICAqIEByZXR1cm5zIENvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3lcclxuICAgICovXHJcbiAgICBwcml2YXRlIF9nZXRQb3NpdGlvbigpOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xyXG4gICAgICAgIGNvbnN0IFtvcmlnaW5YLCBvcmlnaW5GYWxsYmFja1hdOiBIb3Jpem9udGFsQ29ubmVjdGlvblBvc1tdID1cclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblggPT09ICdiZWZvcmUnID8gWydlbmQnLCAnc3RhcnQnXSA6IFsnc3RhcnQnLCAnZW5kJ107XHJcblxyXG4gICAgICAgIGNvbnN0IFtvdmVybGF5WSwgb3ZlcmxheUZhbGxiYWNrWV06IFZlcnRpY2FsQ29ubmVjdGlvblBvc1tdID1cclxuICAgICAgICAgIHRoaXMucG9wb3Zlci5wb3NpdGlvblkgPT09ICdhYm92ZScgPyBbJ2JvdHRvbScsICd0b3AnXSA6IFsndG9wJywgJ2JvdHRvbSddO1xyXG5cclxuICAgICAgICAvLyBsZXQgb3JpZ2luWSA9IG92ZXJsYXlZO1xyXG4gICAgICAgIC8vIGxldCBmYWxsYmFja09yaWdpblkgPSBvdmVybGF5RmFsbGJhY2tZO1xyXG5cclxuICAgICAgICBsZXQgb3JpZ2luWSA9IG92ZXJsYXlZO1xyXG4gICAgICAgIGxldCBvcmlnaW5GYWxsYmFja1kgPSBvdmVybGF5RmFsbGJhY2tZO1xyXG5cclxuICAgICAgICBjb25zdCBvdmVybGF5WCA9IG9yaWdpblg7XHJcbiAgICAgICAgY29uc3Qgb3ZlcmxheUZhbGxiYWNrWCA9IG9yaWdpbkZhbGxiYWNrWDtcclxuXHJcbiAgICAgICAgLy8gbGV0IFtvcmlnaW5ZLCBvcmlnaW5GYWxsYmFja1ldID0gW292ZXJsYXlZLCBvdmVybGF5RmFsbGJhY2tZXTtcclxuICAgICAgICAvLyBsZXQgW292ZXJsYXlYLCBvdmVybGF5RmFsbGJhY2tYXSA9IFtvcmlnaW5YLCBvcmlnaW5GYWxsYmFja1hdO1xyXG5cclxuICAgICAgICAvKiogUmV2ZXJzZSBvdmVybGF5WSBhbmQgZmFsbGJhY2tPdmVybGF5WSB3aGVuIG92ZXJsYXBUcmlnZ2VyIGlzIGZhbHNlICovXHJcbiAgICAgICAgaWYgKCF0aGlzLnBvcG92ZXIub3ZlcmxhcFRyaWdnZXIpIHtcclxuICAgICAgICAgIG9yaWdpblkgPSBvdmVybGF5WSA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xyXG4gICAgICAgICAgb3JpZ2luRmFsbGJhY2tZID0gb3ZlcmxheUZhbGxiYWNrWSA9PT0gJ3RvcCcgPyAnYm90dG9tJyA6ICd0b3AnO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IG9mZnNldFggPSAwO1xyXG4gICAgICAgIGxldCBvZmZzZXRZID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRYICYmICFpc05hTihOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFgpKSkge1xyXG4gICAgICAgICAgb2Zmc2V0WCA9IE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WCk7XHJcbiAgICAgICAgICAvLyBvZmZzZXRYID0gLTE2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMucG9wb3Zlci50YXJnZXRPZmZzZXRZICYmICFpc05hTihOdW1iZXIodGhpcy5wb3BvdmVyLnRhcmdldE9mZnNldFkpKSkge1xyXG4gICAgICAgICAgb2Zmc2V0WSA9IE51bWJlcih0aGlzLnBvcG92ZXIudGFyZ2V0T2Zmc2V0WSk7XHJcbiAgICAgICAgICAvLyBvZmZzZXRZID0gLTEwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9yIG92ZXJyaWRpbmcgcG9zaXRpb24gZWxlbWVudCwgd2hlbiBtZGVQb3BvdmVyVGFyZ2V0QXQgaGFzIGEgdmFsaWQgZWxlbWVudCByZWZlcmVuY2UuXHJcbiAgICAgICAgICogVXNlZnVsIGZvciBzdGlja2luZyBwb3BvdmVyIHRvIHBhcmVudCBlbGVtZW50IGFuZCBvZmZzZXR0aW5nIGFycm93IHRvIHRyaWdnZXIgZWxlbWVudC5cclxuICAgICAgICAgKiBJZiB1bmRlZmluZWQgZGVmYXVsdHMgdG8gdGhlIHRyaWdnZXIgZWxlbWVudCByZWZlcmVuY2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy50YXJnZXRFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuY29udGFpbmVyUG9zaXRpb25pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhpcy50YXJnZXRFbGVtZW50Ll9lbGVtZW50UmVmO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxyXG4gICAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKGVsZW1lbnQpXHJcbiAgICAgICAgLndpdGhQb3NpdGlvbnMoW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG9yaWdpblgsXHJcbiAgICAgICAgICAgICAgb3JpZ2luWSxcclxuICAgICAgICAgICAgICBvdmVybGF5WCxcclxuICAgICAgICAgICAgICBvdmVybGF5WSxcclxuICAgICAgICAgICAgICBvZmZzZXRZXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICAgIG9yaWdpblg6IG9yaWdpbkZhbGxiYWNrWCxcclxuICAgICAgICAgICAgICBvcmlnaW5ZLFxyXG4gICAgICAgICAgICAgIG92ZXJsYXlYOiBvdmVybGF5RmFsbGJhY2tYLFxyXG4gICAgICAgICAgICAgIG92ZXJsYXlZLFxyXG4gICAgICAgICAgICAgIG9mZnNldFlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIG9yaWdpblgsXHJcbiAgICAgICAgICAgIG9yaWdpblk6IG9yaWdpbkZhbGxiYWNrWSxcclxuICAgICAgICAgICAgb3ZlcmxheVgsXHJcbiAgICAgICAgICAgIG92ZXJsYXlZOiBvdmVybGF5RmFsbGJhY2tZLFxyXG4gICAgICAgICAgICBvZmZzZXRZOiAtb2Zmc2V0WVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgb3JpZ2luWDogb3JpZ2luRmFsbGJhY2tYLFxyXG4gICAgICAgICAgICBvcmlnaW5ZOiBvcmlnaW5GYWxsYmFja1ksXHJcbiAgICAgICAgICAgIG92ZXJsYXlYOiBvdmVybGF5RmFsbGJhY2tYLFxyXG4gICAgICAgICAgICBvdmVybGF5WTogb3ZlcmxheUZhbGxiYWNrWSxcclxuICAgICAgICAgICAgb2Zmc2V0WTogLW9mZnNldFlcclxuICAgICAgICAgIH1cclxuICAgICAgICBdKVxyXG4gICAgICAgIC53aXRoRGVmYXVsdE9mZnNldFgob2Zmc2V0WClcclxuICAgICAgICAud2l0aERlZmF1bHRPZmZzZXRZKG9mZnNldFkpO1xyXG4gICAgICAgIC8qXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkucG9zaXRpb24oKVxyXG4gICAgICAgICAgLmNvbm5lY3RlZFRvKGVsZW1lbnQsXHJcbiAgICAgICAgICAgICAge29yaWdpblg6IHBvc1gsIG9yaWdpblk6IG9yaWdpbll9LFxyXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogcG9zWCwgb3ZlcmxheVk6IG92ZXJsYXlZfSlcclxuICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcclxuICAgICAgICAgICAgICB7b3JpZ2luWDogZmFsbGJhY2tYLCBvcmlnaW5ZOiBvcmlnaW5ZfSxcclxuICAgICAgICAgICAgICB7b3ZlcmxheVg6IGZhbGxiYWNrWCwgb3ZlcmxheVk6IG92ZXJsYXlZfSlcclxuICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcclxuICAgICAgICAgICAgICB7b3JpZ2luWDogcG9zWCwgb3JpZ2luWTogZmFsbGJhY2tPcmlnaW5ZfSxcclxuICAgICAgICAgICAgICB7b3ZlcmxheVg6IHBvc1gsIG92ZXJsYXlZOiBmYWxsYmFja092ZXJsYXlZfSlcclxuICAgICAgICAgIC53aXRoRmFsbGJhY2tQb3NpdGlvbihcclxuICAgICAgICAgICAgICB7b3JpZ2luWDogZmFsbGJhY2tYLCBvcmlnaW5ZOiBmYWxsYmFja09yaWdpbll9LFxyXG4gICAgICAgICAgICAgIHtvdmVybGF5WDogZmFsbGJhY2tYLCBvdmVybGF5WTogZmFsbGJhY2tPdmVybGF5WX0pXHJcbiAgICAgICAgICAud2l0aE9mZnNldFgob2Zmc2V0WClcclxuICAgICAgICAgIC53aXRoT2Zmc2V0WShvZmZzZXRZKTtcclxuICAgICAgICAgICovXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfY2xlYW5VcFN1YnNjcmlwdGlvbnMoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhY2tkcm9wU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWRvd24nLCBbJyRldmVudCddKSBfaGFuZGxlTW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKGV2ZW50ICYmICFpc0Zha2VNb3VzZWRvd25Gcm9tU2NyZWVuUmVhZGVyKGV2ZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9vcGVuZWRCeU1vdXNlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuIl19